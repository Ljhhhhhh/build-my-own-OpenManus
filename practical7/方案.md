# 项目 7：沙箱执行环境 - 简化实战方案

## 🎯 项目目标（简化版）

让你通过**渐进式学习**掌握沙箱环境的核心概念和实战技能：

1. **理解沙箱本质**：从最简单的代码隔离开始
2. **掌握核心技术**：逐步学习 subprocess → Docker 的演进
3. **实战驱动学习**：每个阶段都有可运行的代码
4. **循序渐进**：从 30 行代码到完整沙箱系统

## 🏗️ 简化架构设计

### 三层渐进式架构

```
第一层：基础沙箱 (30行代码)
┌─────────────────────────────────┐
│        SimpleSandbox            │
│  ┌─────────────────────────────┐ │
│  │    subprocess.run()         │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘

第二层：安全沙箱 (100行代码)
┌─────────────────────────────────┐
│        SafeSandbox              │
│  ┌─────────────┐ ┌─────────────┐ │
│  │ 资源限制     │ │ 安全检查     │ │
│  └─────────────┘ └─────────────┘ │
└─────────────────────────────────┘

第三层：Docker沙箱 (200行代码)
┌─────────────────────────────────┐
│       DockerSandbox             │
│  ┌─────────────┐ ┌─────────────┐ │
│  │ 容器隔离     │ │ 镜像管理     │ │
│  └─────────────┘ └─────────────┘ │
└─────────────────────────────────┘
```

## 📚 学习路径（3 个阶段）

### 🚀 阶段 1：基础沙箱（1 天）

**目标**：理解沙箱的本质概念

**核心概念**：

- 进程隔离
- 输入输出控制
- 基础安全

**实现内容**：

```python
# 30行代码实现基础沙箱
class SimpleSandbox:
    def execute(self, code: str) -> dict:
        # 使用subprocess执行代码
        pass
```

### 🛡️ 阶段 2：安全沙箱（2 天）

**目标**：添加安全控制和资源限制

**核心概念**：

- 超时控制
- 内存限制
- 危险代码检测

**实现内容**：

```python
# 100行代码实现安全沙箱
class SafeSandbox(SimpleSandbox):
    def __init__(self, timeout=10, memory_limit=128):
        # 添加安全配置
        pass

    def validate_code(self, code: str) -> bool:
        # 检查危险代码
        pass
```

### 🐳 阶段 3：Docker 沙箱（2 天）

**目标**：使用 Docker 实现完全隔离

**核心概念**：

- 容器技术
- 镜像管理
- 网络隔离

**实现内容**：

```python
# 200行代码实现Docker沙箱
class DockerSandbox:
    def __init__(self):
        self.client = docker.from_env()

    def execute_in_container(self, code: str) -> dict:
        # 在Docker容器中执行
        pass
```

## 📁 简化项目结构

```
practical7/
├── README.md                    # 项目说明
├── requirements.txt             # 依赖列表
├── .env.example                # 环境配置
├── main.py                     # 主程序入口
├── demo.py                     # 演示程序
├── stage1_simple_sandbox.py     # 阶段1：基础沙箱
├── stage2_safe_sandbox.py       # 阶段2：安全沙箱
├── stage3_docker_sandbox.py     # 阶段3：Docker沙箱
├── utils/
│   ├── __init__.py
│   ├── config.py               # 简化配置
│   └── logger.py               # 日志工具
├── tests/
│   ├── test_stage1.py          # 阶段1测试
│   ├── test_stage2.py          # 阶段2测试
│   └── test_stage3.py          # 阶段3测试
└── examples/
    ├── basic_usage.py          # 基础使用示例
    ├── security_demo.py        # 安全演示
    └── docker_demo.py          # Docker演示
```

## 🔧 阶段 1 详细实现：基础沙箱

### 核心文件：stage1_simple_sandbox.py

```python
"""
阶段1：基础沙箱实现
目标：理解沙箱的本质 - 进程隔离和输入输出控制
"""

import subprocess
import tempfile
import os
import time
from typing import Dict, Any


class SimpleSandbox:
    """最简单的沙箱实现 - 30行核心代码"""

    def __init__(self, timeout: int = 10):
        self.timeout = timeout

    def execute(self, code: str, language: str = "python") -> Dict[str, Any]:
        """执行代码并返回结果"""
        start_time = time.time()

        # 1. 创建临时文件
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix=f'.{self._get_extension(language)}',
            delete=False
        ) as f:
            f.write(code)
            temp_file = f.name

        try:
            # 2. 执行代码
            result = subprocess.run(
                [self._get_command(language), temp_file],
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            # 3. 返回结果
            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'execution_time': time.time() - start_time,
                'exit_code': result.returncode
            }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'output': '',
                'error': f'代码执行超时（{self.timeout}秒）',
                'execution_time': self.timeout,
                'exit_code': -1
            }
        finally:
            # 4. 清理临时文件
            os.unlink(temp_file)

    def _get_extension(self, language: str) -> str:
        """获取文件扩展名"""
        return {'python': 'py', 'javascript': 'js'}.get(language, 'txt')

    def _get_command(self, language: str) -> str:
        """获取执行命令"""
        return {'python': 'python', 'javascript': 'node'}.get(language, 'cat')


# 使用示例
if __name__ == "__main__":
    sandbox = SimpleSandbox(timeout=5)

    # 测试Python代码
    python_code = """
print("Hello from sandbox!")
result = 2 + 3
print(f"2 + 3 = {result}")
"""

    result = sandbox.execute(python_code, "python")
    print("执行结果：", result)
```

### 学习要点

**与 JavaScript 对比理解**：

```javascript
// JavaScript中的代码执行
const vm = require('vm');
const result = vm.runInNewContext('2 + 3');

// Python沙箱等价概念
sandbox = SimpleSandbox();
result = sandbox.execute('print(2 + 3)');
```

**核心概念掌握**：

1. **进程隔离**：`subprocess.run()` 创建新进程
2. **输入输出控制**：`capture_output=True` 捕获输出
3. **超时保护**：`timeout` 参数防止无限循环
4. **资源清理**：`finally` 块确保临时文件删除

## 🔧 阶段 2 详细实现：安全沙箱

### 核心文件：stage2_safe_sandbox.py

```python
"""
阶段2：安全沙箱实现
目标：添加安全检查和资源限制
"""

import psutil
import resource
import re
from stage1_simple_sandbox import SimpleSandbox


class SafeSandbox(SimpleSandbox):
    """安全沙箱 - 在基础沙箱上添加安全控制"""

    def __init__(self, timeout: int = 10, memory_limit: int = 128):
        super().__init__(timeout)
        self.memory_limit = memory_limit * 1024 * 1024  # 转换为字节

        # 危险关键词列表
        self.dangerous_keywords = [
            'os.system', 'subprocess', 'eval', 'exec',
            'open(', '__import__', 'input(', 'raw_input'
        ]

    def execute(self, code: str, language: str = "python") -> Dict[str, Any]:
        """安全执行代码"""
        # 1. 代码安全检查
        if not self._validate_code(code):
            return {
                'success': False,
                'output': '',
                'error': '代码包含危险操作，执行被拒绝',
                'execution_time': 0,
                'exit_code': -1
            }

        # 2. 设置资源限制
        self._set_resource_limits()

        # 3. 执行代码（调用父类方法）
        result = super().execute(code, language)

        # 4. 添加安全信息
        result['security_check'] = True
        result['memory_limit'] = self.memory_limit

        return result

    def _validate_code(self, code: str) -> bool:
        """验证代码安全性"""
        # 检查危险关键词
        for keyword in self.dangerous_keywords:
            if keyword in code:
                return False

        # 检查导入语句
        import_pattern = r'import\s+(os|sys|subprocess|socket)'
        if re.search(import_pattern, code):
            return False

        return True

    def _set_resource_limits(self):
        """设置进程资源限制"""
        try:
            # 设置内存限制
            resource.setrlimit(resource.RLIMIT_AS, (self.memory_limit, self.memory_limit))

            # 设置CPU时间限制
            resource.setrlimit(resource.RLIMIT_CPU, (self.timeout, self.timeout))
        except:
            # 某些系统可能不支持资源限制
            pass


# 使用示例
if __name__ == "__main__":
    sandbox = SafeSandbox(timeout=5, memory_limit=64)

    # 测试安全代码
    safe_code = """
numbers = [1, 2, 3, 4, 5]
total = sum(numbers)
print(f"总和: {total}")
"""

    # 测试危险代码
    dangerous_code = """
import os
os.system("ls -la")
"""

    print("安全代码执行结果：")
    print(sandbox.execute(safe_code))

    print("\n危险代码执行结果：")
    print(sandbox.execute(dangerous_code))
```

## 🔧 阶段 3 详细实现：Docker 沙箱

### 核心文件：stage3_docker_sandbox.py

```python
"""
阶段3：Docker沙箱实现
目标：使用Docker容器实现完全隔离
"""

import docker
import tempfile
import os
import time
from typing import Dict, Any


class DockerSandbox:
    """Docker沙箱 - 完全隔离的执行环境"""

    def __init__(self, timeout: int = 30, memory_limit: str = "128m"):
        self.timeout = timeout
        self.memory_limit = memory_limit
        self.client = docker.from_env()

        # 语言镜像映射
        self.images = {
            'python': 'python:3.9-slim',
            'javascript': 'node:18-slim'
        }

        # 确保镜像存在
        self._ensure_images()

    def execute(self, code: str, language: str = "python") -> Dict[str, Any]:
        """在Docker容器中执行代码"""
        start_time = time.time()

        if language not in self.images:
            return {
                'success': False,
                'output': '',
                'error': f'不支持的语言: {language}',
                'execution_time': 0
            }

        # 1. 创建临时文件
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix=f'.{self._get_extension(language)}',
            delete=False
        ) as f:
            f.write(code)
            temp_file = f.name

        try:
            # 2. 在容器中执行
            result = self._run_in_container(temp_file, language)
            result['execution_time'] = time.time() - start_time
            return result

        finally:
            # 3. 清理临时文件
            os.unlink(temp_file)

    def _run_in_container(self, code_file: str, language: str) -> Dict[str, Any]:
        """在Docker容器中运行代码"""
        try:
            # 容器配置
            container_config = {
                'image': self.images[language],
                'command': self._get_command(language, os.path.basename(code_file)),
                'volumes': {
                    os.path.dirname(code_file): {
                        'bind': '/workspace',
                        'mode': 'ro'  # 只读模式
                    }
                },
                'working_dir': '/workspace',
                'mem_limit': self.memory_limit,
                'network_disabled': True,  # 禁用网络
                'remove': True,  # 自动删除容器
                'user': '1000:1000'  # 非root用户
            }

            # 运行容器
            container = self.client.containers.run(**container_config, detach=True)

            # 等待执行完成
            exit_status = container.wait(timeout=self.timeout)

            # 获取输出
            logs = container.logs().decode('utf-8')

            return {
                'success': exit_status['StatusCode'] == 0,
                'output': logs if exit_status['StatusCode'] == 0 else '',
                'error': logs if exit_status['StatusCode'] != 0 else '',
                'exit_code': exit_status['StatusCode'],
                'container_id': container.id[:12]
            }

        except docker.errors.ContainerError as e:
            return {
                'success': False,
                'output': '',
                'error': f'容器执行错误: {str(e)}',
                'exit_code': e.exit_status
            }
        except Exception as e:
            return {
                'success': False,
                'output': '',
                'error': f'Docker执行异常: {str(e)}',
                'exit_code': -1
            }

    def _ensure_images(self):
        """确保所需镜像存在"""
        for language, image in self.images.items():
            try:
                self.client.images.get(image)
                print(f"✓ 镜像 {image} 已存在")
            except docker.errors.ImageNotFound:
                print(f"⬇ 正在拉取镜像 {image}...")
                self.client.images.pull(image)
                print(f"✓ 镜像 {image} 拉取完成")

    def _get_extension(self, language: str) -> str:
        return {'python': 'py', 'javascript': 'js'}.get(language, 'txt')

    def _get_command(self, language: str, filename: str) -> list:
        commands = {
            'python': ['python', filename],
            'javascript': ['node', filename]
        }
        return commands.get(language, ['cat', filename])


# 使用示例
if __name__ == "__main__":
    sandbox = DockerSandbox(timeout=10, memory_limit="64m")

    # 测试Python代码
    python_code = """
import math
print("Docker沙箱中的Python执行")
print(f"π的值: {math.pi}")
print(f"2的平方根: {math.sqrt(2)}")
"""

    result = sandbox.execute(python_code, "python")
    print("Docker执行结果：", result)
```

## 🎯 学习重点和对比

### JavaScript 开发者的理解路径

| 概念     | JavaScript 等价         | Python 沙箱实现        |
| -------- | ----------------------- | ---------------------- |
| 进程隔离 | `child_process.spawn()` | `subprocess.run()`     |
| 代码执行 | `vm.runInNewContext()`  | `exec()` in subprocess |
| 容器化   | Docker for Node.js      | Docker for Python      |
| 资源限制 | `--max-old-space-size`  | `resource.setrlimit()` |
| 超时控制 | `setTimeout()`          | `timeout` parameter    |

### 核心安全概念

1. **输入验证**：检查危险代码模式
2. **资源限制**：内存、CPU、时间控制
3. **进程隔离**：独立进程空间
4. **容器隔离**：Docker 完全隔离
5. **网络隔离**：禁用网络访问

## 📋 实践计划

### 第 1 天：基础沙箱

- [ ] 理解 `subprocess` 模块
- [ ] 实现 `SimpleSandbox` 类
- [ ] 测试基本代码执行
- [ ] 添加超时保护

### 第 2 天：安全增强

- [ ] 学习代码安全检查
- [ ] 实现 `SafeSandbox` 类
- [ ] 添加资源限制
- [ ] 测试危险代码拦截

### 第 3 天：Docker 集成

- [ ] 学习 Docker 基础命令
- [ ] 安装 Docker Python SDK
- [ ] 实现 `DockerSandbox` 类
- [ ] 测试容器隔离

### 第 4 天：集成测试

- [ ] 编写完整测试用例
- [ ] 性能测试和优化
- [ ] 文档完善
- [ ] 部署准备

## 🚀 快速开始

1. **克隆项目结构**：

```bash
mkdir practical7 && cd practical7
touch stage1_simple_sandbox.py stage2_safe_sandbox.py stage3_docker_sandbox.py
```

2. **安装依赖**：

```bash
pip install psutil docker
```

3. **运行阶段 1**：

```bash
python stage1_simple_sandbox.py
```

这个方案让你能够：

- **循序渐进**：从 30 行代码开始，逐步增加复杂度
- **概念清晰**：每个阶段专注一个核心概念
- **实战导向**：每个阶段都有可运行的完整代码
- **易于理解**：避免过度抽象，专注核心功能

你觉得这个简化方案如何？我们可以从哪个阶段开始实践？
