# é¡¹ç›®7ï¼šæ²™ç®±æ‰§è¡Œç¯å¢ƒ - è¯¦ç»†å¼€å‘æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

åŸºäºé¡¹ç›®6çš„å¤šæ¨¡æ€ä»£ç†æ¶æ„ï¼Œå®ç°å®‰å…¨çš„ä»£ç æ‰§è¡Œç¯å¢ƒï¼Œæ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€ï¼Œæä¾›èµ„æºé™åˆ¶å’Œå®‰å…¨éš”ç¦»ï¼Œå¹¶é›†æˆåˆ°AIä»£ç†å·¥ä½œæµä¸­ã€‚

### ğŸ¯ é¡¹ç›®ç›®æ ‡

1. **å®‰å…¨éš”ç¦»**ï¼šä½¿ç”¨Dockerå®¹å™¨æä¾›å®‰å…¨çš„ä»£ç æ‰§è¡Œç¯å¢ƒ
2. **å¤šè¯­è¨€æ”¯æŒ**ï¼šæ”¯æŒPythonã€JavaScriptã€Javaã€Goç­‰ä¸»æµç¼–ç¨‹è¯­è¨€
3. **èµ„æºæ§åˆ¶**ï¼šå®ç°CPUã€å†…å­˜ã€æ—¶é—´ç­‰èµ„æºé™åˆ¶
4. **ä»£ç†é›†æˆ**ï¼šæ— ç¼é›†æˆåˆ°ç°æœ‰çš„ReActä»£ç†æ¶æ„ä¸­
5. **ä¼šè¯ç®¡ç†**ï¼šæ”¯æŒé•¿æœŸä»£ç æ‰§è¡Œä¼šè¯å’ŒçŠ¶æ€ç®¡ç†

### ğŸ—ï¸ æ¶æ„è®¾è®¡

#### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SandboxAgent                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   ReAct Logic   â”‚  â”‚  Tool Manager   â”‚  â”‚   Config    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Sandbox Tools                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Code Executor   â”‚  â”‚Session Manager  â”‚  â”‚ File Managerâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Sandbox Layer                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  BaseSandbox    â”‚  â”‚ DockerSandbox   â”‚  â”‚ProcessSandboxâ”‚ â”‚
â”‚  â”‚  (Abstract)     â”‚  â”‚ (Production)    â”‚  â”‚ (Development)â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Docker Infrastructure                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚Python Container â”‚  â”‚  JS Container   â”‚  â”‚Java Containerâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## è¯¦ç»†å®ç°è®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€è®¾æ–½æ­å»º (ç¬¬1-2å¤©)

#### 1.1 é¡¹ç›®ç»“æ„åˆ›å»º

```
practical7/
â”œâ”€â”€ README.md                    # é¡¹ç›®è¯´æ˜æ–‡æ¡£
â”œâ”€â”€ requirements.txt             # ä¾èµ–åŒ…åˆ—è¡¨
â”œâ”€â”€ .env.example                # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”œâ”€â”€ main.py                     # ä¸»ç¨‹åºå…¥å£
â”œâ”€â”€ demo.py                     # æ¼”ç¤ºç¨‹åº
â”œâ”€â”€ æ–¹æ¡ˆ.md                     # æœ¬æ–‡æ¡£
â”œâ”€â”€ sandbox/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py                 # æ²™ç®±åŸºç±»å’Œæ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ docker_sandbox.py       # Dockeræ²™ç®±å®ç°
â”‚   â””â”€â”€ process_sandbox.py      # è¿›ç¨‹æ²™ç®±å®ç°ï¼ˆå¼€å‘ç”¨ï¼‰
â”œâ”€â”€ agent/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ sandbox_agent.py        # æ²™ç®±ä»£ç†
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py                 # ç»§æ‰¿è‡ªé¡¹ç›®6
â”‚   â”œâ”€â”€ manager.py              # ç»§æ‰¿è‡ªé¡¹ç›®6
â”‚   â”œâ”€â”€ code_executor.py        # ä»£ç æ‰§è¡Œå·¥å…·
â”‚   â”œâ”€â”€ session_manager.py      # ä¼šè¯ç®¡ç†å·¥å…·
â”‚   â””â”€â”€ file_manager.py         # æ–‡ä»¶ç®¡ç†å·¥å…·
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ config.py               # æ‰©å±•é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ logger.py               # æ—¥å¿—ç³»ç»Ÿ
â”‚   â””â”€â”€ security.py             # å®‰å…¨å·¥å…·
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_sandbox.py         # æ²™ç®±æµ‹è¯•
â”‚   â”œâ”€â”€ test_agent.py           # ä»£ç†æµ‹è¯•
â”‚   â”œâ”€â”€ test_tools.py           # å·¥å…·æµ‹è¯•
â”‚   â””â”€â”€ test_integration.py     # é›†æˆæµ‹è¯•
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ python/
â”‚   â”‚   â””â”€â”€ Dockerfile          # Pythonæ‰§è¡Œç¯å¢ƒ
â”‚   â”œâ”€â”€ javascript/
â”‚   â”‚   â””â”€â”€ Dockerfile          # JavaScriptæ‰§è¡Œç¯å¢ƒ
â”‚   â””â”€â”€ java/
â”‚       â””â”€â”€ Dockerfile          # Javaæ‰§è¡Œç¯å¢ƒ
â””â”€â”€ logs/
    â””â”€â”€ sandbox.log             # æ—¥å¿—æ–‡ä»¶
```

#### 1.2 ä¾èµ–ç®¡ç†

**requirements.txt**:
```txt
# åŸºç¡€ä¾èµ–ï¼ˆç»§æ‰¿è‡ªé¡¹ç›®6ï¼‰
openai>=1.0.0
pydantic>=2.0.0
python-dotenv>=1.0.0
asyncio
typing-extensions>=4.0.0

# æ²™ç®±ç‰¹å®šä¾èµ–
docker>=6.0.0                  # Docker Python SDK
psutil>=5.9.0                  # ç³»ç»Ÿèµ„æºç›‘æ§
resource                       # èµ„æºé™åˆ¶ï¼ˆå†…ç½®ï¼‰
tempfile                       # ä¸´æ—¶æ–‡ä»¶ç®¡ç†ï¼ˆå†…ç½®ï¼‰
uuid                           # ä¼šè¯IDç”Ÿæˆï¼ˆå†…ç½®ï¼‰

# å®‰å…¨ç›¸å…³
cryptography>=41.0.0           # åŠ å¯†å’Œå®‰å…¨
hashlib                        # å“ˆå¸Œè®¡ç®—ï¼ˆå†…ç½®ï¼‰

# æµ‹è¯•æ¡†æ¶
pytest>=7.0.0
pytest-asyncio>=0.21.0
pytest-docker>=2.0.0

# å¼€å‘å·¥å…·
black>=23.0.0                  # ä»£ç æ ¼å¼åŒ–
flake8>=6.0.0                  # ä»£ç æ£€æŸ¥
mypy>=1.0.0                    # ç±»å‹æ£€æŸ¥
```

#### 1.3 é…ç½®ç³»ç»Ÿæ‰©å±•

åŸºäºé¡¹ç›®6çš„Configç±»ï¼Œæ‰©å±•æ²™ç®±ç›¸å…³é…ç½®ï¼š

```python
# utils/config.py æ‰©å±•éƒ¨åˆ†
@dataclass
class Config:
    # ... ç»§æ‰¿é¡¹ç›®6çš„æ‰€æœ‰é…ç½® ...
    
    # æ²™ç®±åŸºç¡€é…ç½®
    sandbox_type: str = "docker"  # "docker", "process"
    sandbox_timeout: int = 30     # é»˜è®¤è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    sandbox_memory_limit: int = 512  # å†…å­˜é™åˆ¶ï¼ˆMBï¼‰
    sandbox_cpu_limit: float = 1.0   # CPUé™åˆ¶
    sandbox_network_access: bool = False  # ç½‘ç»œè®¿é—®
    sandbox_file_system_access: bool = False  # æ–‡ä»¶ç³»ç»Ÿè®¿é—®
    
    # Dockerç‰¹å®šé…ç½®
    docker_host: str = "unix://var/run/docker.sock"
    docker_api_version: str = "auto"
    docker_timeout: int = 60
    docker_auto_remove: bool = True
    docker_pull_policy: str = "missing"  # "always", "missing", "never"
    
    # æ”¯æŒçš„è¯­è¨€é…ç½®
    supported_languages: List[str] = field(default_factory=lambda: [
        "python", "javascript", "java", "go", "bash"
    ])
    
    # è¯­è¨€ç‰¹å®šé…ç½®
    python_version: str = "3.12"
    node_version: str = "18"
    java_version: str = "11"
    go_version: str = "1.19"
    
    # å®‰å…¨é…ç½®
    max_concurrent_executions: int = 5
    max_session_duration: int = 3600  # 1å°æ—¶
    max_file_size: int = 1024 * 1024  # 1MB
    allowed_imports: List[str] = field(default_factory=list)
    blocked_imports: List[str] = field(default_factory=lambda: [
        "os", "subprocess", "socket", "urllib", "requests"
    ])
```

### é˜¶æ®µ2ï¼šæ²™ç®±æ ¸å¿ƒå®ç° (ç¬¬3-5å¤©)

#### 2.1 æ²™ç®±åŸºç±»å®ç°

**sandbox/base.py**:
```python
"""
æ²™ç®±åŸºç±»å’Œæ•°æ®æ¨¡å‹

å®šä¹‰æ²™ç®±ç³»ç»Ÿçš„æ ¸å¿ƒæŠ½è±¡å’Œæ•°æ®ç»“æ„ã€‚
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum
import time
import uuid
from pydantic import BaseModel, Field


class ExecutionStatus(str, Enum):
    """æ‰§è¡ŒçŠ¶æ€æšä¸¾"""
    SUCCESS = "success"
    ERROR = "error"
    TIMEOUT = "timeout"
    MEMORY_LIMIT = "memory_limit"
    CPU_LIMIT = "cpu_limit"
    SECURITY_VIOLATION = "security_violation"


@dataclass
class ExecutionResult:
    """æ‰§è¡Œç»“æœæ•°æ®ç±»"""
    success: bool
    output: str
    error: str
    execution_time: float
    memory_usage: Optional[int] = None
    exit_code: Optional[int] = None
    session_id: str = ""
    status: ExecutionStatus = ExecutionStatus.SUCCESS
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸æ ¼å¼"""
        return {
            "success": self.success,
            "output": self.output,
            "error": self.error,
            "execution_time": self.execution_time,
            "memory_usage": self.memory_usage,
            "exit_code": self.exit_code,
            "session_id": self.session_id,
            "status": self.status.value,
            "metadata": self.metadata
        }


@dataclass
class SandboxConfig:
    """æ²™ç®±é…ç½®æ•°æ®ç±»"""
    timeout: int = 30
    memory_limit: int = 512  # MB
    cpu_limit: float = 1.0
    network_access: bool = False
    file_system_access: bool = False
    allowed_imports: List[str] = field(default_factory=list)
    blocked_imports: List[str] = field(default_factory=list)
    max_output_size: int = 1024 * 1024  # 1MB
    working_directory: str = "/workspace"
    
    def validate(self) -> None:
        """éªŒè¯é…ç½®å‚æ•°"""
        if self.timeout <= 0:
            raise ValueError("timeout must be positive")
        if self.memory_limit <= 0:
            raise ValueError("memory_limit must be positive")
        if self.cpu_limit <= 0:
            raise ValueError("cpu_limit must be positive")


class BaseSandbox(ABC):
    """æ²™ç®±æŠ½è±¡åŸºç±»"""
    
    def __init__(self, config: SandboxConfig):
        self.config = config
        self.config.validate()
        self.sessions: Dict[str, Dict[str, Any]] = {}
        self._stats = {
            "total_executions": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "total_execution_time": 0.0
        }
    
    @abstractmethod
    async def execute(self, code: str, language: str = "python", 
                     session_id: Optional[str] = None) -> ExecutionResult:
        """æ‰§è¡Œä»£ç """
        pass
    
    @abstractmethod
    async def create_session(self) -> str:
        """åˆ›å»ºæ–°ä¼šè¯"""
        pass
    
    @abstractmethod
    async def destroy_session(self, session_id: str) -> bool:
        """é”€æ¯ä¼šè¯"""
        pass
    
    @abstractmethod
    async def list_sessions(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æ´»è·ƒä¼šè¯"""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """æ¸…ç†èµ„æº"""
        pass
    
    def generate_session_id(self) -> str:
        """ç”Ÿæˆå”¯ä¸€ä¼šè¯ID"""
        return str(uuid.uuid4())
    
    def update_stats(self, result: ExecutionResult) -> None:
        """æ›´æ–°ç»Ÿè®¡ä¿¡æ¯"""
        self._stats["total_executions"] += 1
        if result.success:
            self._stats["successful_executions"] += 1
        else:
            self._stats["failed_executions"] += 1
        self._stats["total_execution_time"] += result.execution_time
    
    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return self._stats.copy()
```

#### 2.2 Dockeræ²™ç®±å®ç°

**sandbox/docker_sandbox.py**:
```python
"""
Dockeræ²™ç®±å®ç°

ä½¿ç”¨Dockerå®¹å™¨æä¾›å®‰å…¨çš„ä»£ç æ‰§è¡Œç¯å¢ƒã€‚
"""

import docker
import asyncio
import tempfile
import os
import time
import logging
from typing import Dict, Any, Optional, List
from pathlib import Path

from .base import BaseSandbox, ExecutionResult, SandboxConfig, ExecutionStatus
from ..utils.logger import get_logger

logger = get_logger(__name__)


class DockerSandbox(BaseSandbox):
    """Dockeræ²™ç®±å®ç°"""
    
    def __init__(self, config: SandboxConfig):
        super().__init__(config)
        self.client = docker.from_env()
        self.language_images = {
            'python': 'python:3.9-slim',
            'javascript': 'node:18-slim',
            'java': 'openjdk:11-slim',
            'go': 'golang:1.19-slim',
            'bash': 'ubuntu:22.04'
        }
        self._ensure_images()
    
    def _ensure_images(self) -> None:
        """ç¡®ä¿æ‰€éœ€é•œåƒå­˜åœ¨"""
        for language, image in self.language_images.items():
            try:
                self.client.images.get(image)
                logger.info(f"é•œåƒ {image} å·²å­˜åœ¨")
            except docker.errors.ImageNotFound:
                logger.info(f"æ‹‰å–é•œåƒ {image}...")
                self.client.images.pull(image)
                logger.info(f"é•œåƒ {image} æ‹‰å–å®Œæˆ")
    
    async def execute(self, code: str, language: str = "python", 
                     session_id: Optional[str] = None) -> ExecutionResult:
        """åœ¨Dockerå®¹å™¨ä¸­æ‰§è¡Œä»£ç """
        start_time = time.time()
        
        try:
            # éªŒè¯è¯­è¨€æ”¯æŒ
            if language not in self.language_images:
                return ExecutionResult(
                    success=False,
                    output="",
                    error=f"ä¸æ”¯æŒçš„è¯­è¨€: {language}",
                    execution_time=0,
                    status=ExecutionStatus.ERROR
                )
            
            # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
            with tempfile.NamedTemporaryFile(
                mode='w', 
                suffix=self._get_file_extension(language), 
                delete=False
            ) as f:
                f.write(code)
                temp_file = f.name
            
            try:
                # è¿è¡Œå®¹å™¨
                result = await self._run_container(
                    self.language_images[language], 
                    temp_file, 
                    language
                )
                
                execution_time = time.time() - start_time
                
                exec_result = ExecutionResult(
                    success=result['exit_code'] == 0,
                    output=result['output'],
                    error=result['error'],
                    execution_time=execution_time,
                    exit_code=result['exit_code'],
                    session_id=session_id or "",
                    status=ExecutionStatus.SUCCESS if result['exit_code'] == 0 else ExecutionStatus.ERROR,
                    metadata={
                        'language': language,
                        'container_id': result.get('container_id', ''),
                        'memory_usage': result.get('memory_usage', 0)
                    }
                )
                
                self.update_stats(exec_result)
                return exec_result
                
            finally:
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                os.unlink(temp_file)
                
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"ä»£ç æ‰§è¡Œå¼‚å¸¸: {e}")
            
            result = ExecutionResult(
                success=False,
                output="",
                error=str(e),
                execution_time=execution_time,
                status=ExecutionStatus.ERROR
            )
            self.update_stats(result)
            return result
    
    async def _run_container(self, image: str, code_file: str, language: str) -> Dict[str, Any]:
        """è¿è¡ŒDockerå®¹å™¨"""
        command = self._get_run_command(language, os.path.basename(code_file))
        
        # å®¹å™¨é…ç½®
        container_config = {
            'image': image,
            'command': command,
            'volumes': {
                os.path.dirname(code_file): {
                    'bind': '/workspace', 
                    'mode': 'ro'
                }
            },
            'working_dir': '/workspace',
            'mem_limit': f'{self.config.memory_limit}m',
            'cpu_period': 100000,
            'cpu_quota': int(100000 * self.config.cpu_limit),
            'network_disabled': not self.config.network_access,
            'remove': True,
            'stdout': True,
            'stderr': True,
            'user': '1000:1000',  # érootç”¨æˆ·
            'security_opt': ['no-new-privileges:true'],  # å®‰å…¨é€‰é¡¹
            'cap_drop': ['ALL'],  # ç§»é™¤æ‰€æœ‰capabilities
            'read_only': True,  # åªè¯»æ–‡ä»¶ç³»ç»Ÿ
            'tmpfs': {'/tmp': 'noexec,nosuid,size=100m'}  # ä¸´æ—¶æ–‡ä»¶ç³»ç»Ÿ
        }
        
        container = None
        try:
            # åˆ›å»ºå¹¶å¯åŠ¨å®¹å™¨
            container = self.client.containers.run(**container_config, detach=True)
            
            # ç­‰å¾…æ‰§è¡Œå®Œæˆ
            result = container.wait(timeout=self.config.timeout)
            
            # è·å–è¾“å‡º
            logs = container.logs(stdout=True, stderr=True).decode('utf-8')
            
            # è·å–å®¹å™¨ç»Ÿè®¡ä¿¡æ¯
            stats = container.stats(stream=False)
            memory_usage = stats['memory_stats'].get('usage', 0)
            
            return {
                'exit_code': result['StatusCode'],
                'output': logs if result['StatusCode'] == 0 else '',
                'error': logs if result['StatusCode'] != 0 else '',
                'container_id': container.id,
                'memory_usage': memory_usage
            }
            
        except docker.errors.ContainerError as e:
            return {
                'exit_code': e.exit_status,
                'output': '',
                'error': str(e),
                'container_id': container.id if container else ''
            }
        except Exception as e:
            return {
                'exit_code': -1,
                'output': '',
                'error': str(e),
                'container_id': container.id if container else ''
            }
        finally:
            # ç¡®ä¿å®¹å™¨è¢«æ¸…ç†
            if container:
                try:
                    container.remove(force=True)
                except:
                    pass
    
    def _get_file_extension(self, language: str) -> str:
        """è·å–æ–‡ä»¶æ‰©å±•å"""
        extensions = {
            'python': '.py',
            'javascript': '.js',
            'java': '.java',
            'go': '.go',
            'bash': '.sh'
        }
        return extensions.get(language, '.txt')
    
    def _get_run_command(self, language: str, filename: str) -> List[str]:
        """è·å–è¿è¡Œå‘½ä»¤"""
        commands = {
            'python': ['python', filename],
            'javascript': ['node', filename],
            'java': ['sh', '-c', f'javac {filename} && java {filename[:-5]}'],
            'go': ['go', 'run', filename],
            'bash': ['bash', filename]
        }
        return commands.get(language, ['cat', filename])
    
    async def create_session(self) -> str:
        """åˆ›å»ºæ–°ä¼šè¯"""
        session_id = self.generate_session_id()
        self.sessions[session_id] = {
            'created_at': time.time(),
            'last_used': time.time(),
            'executions': 0
        }
        logger.info(f"åˆ›å»ºä¼šè¯: {session_id}")
        return session_id
    
    async def destroy_session(self, session_id: str) -> bool:
        """é”€æ¯ä¼šè¯"""
        if session_id in self.sessions:
            del self.sessions[session_id]
            logger.info(f"é”€æ¯ä¼šè¯: {session_id}")
            return True
        return False
    
    async def list_sessions(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰æ´»è·ƒä¼šè¯"""
        return list(self.sessions.keys())
    
    async def cleanup(self) -> None:
        """æ¸…ç†èµ„æº"""
        # æ¸…ç†æ‰€æœ‰ä¼šè¯
        for session_id in list(self.sessions.keys()):
            await self.destroy_session(session_id)
        
        # æ¸…ç†Dockerèµ„æº
        try:
            # æ¸…ç†æ‚¬ç©ºå®¹å™¨
            containers = self.client.containers.list(
                all=True, 
                filters={'status': 'exited'}
            )
            for container in containers:
                if 'sandbox' in container.name:
                    container.remove()
            
            logger.info("Dockerèµ„æºæ¸…ç†å®Œæˆ")
        except Exception as e:
            logger.error(f"Dockerèµ„æºæ¸…ç†å¤±è´¥: {e}")
```

### é˜¶æ®µ3ï¼šå·¥å…·ç³»ç»Ÿé›†æˆ (ç¬¬6-7å¤©)

#### 3.1 ä»£ç æ‰§è¡Œå·¥å…·

**tools/code_executor.py**:
```python
"""
ä»£ç æ‰§è¡Œå·¥å…·

å°†æ²™ç®±åŠŸèƒ½å°è£…ä¸ºå·¥å…·ï¼Œé›†æˆåˆ°å·¥å…·ç®¡ç†ç³»ç»Ÿä¸­ã€‚
"""

import asyncio
import logging
from typing import Dict, Any, Optional, Union
from pathlib import Path

# ç»§æ‰¿é¡¹ç›®6çš„åŸºç¡€å·¥å…·ç±»
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', 'practical6'))

from practical6.tools.base import BaseTool, ToolResult, ToolResultStatus
from ..sandbox.docker_sandbox import DockerSandbox
from ..sandbox.base import SandboxConfig
from ..utils.config import get_config
from ..utils.logger import get_logger

logger = get_logger(__name__)


class CodeExecutorTool(BaseTool):
    """ä»£ç æ‰§è¡Œå·¥å…·"""
    
    def __init__(self):
        super().__init__(
            name="code_executor",
            description="å®‰å…¨æ‰§è¡Œä»£ç å¹¶è¿”å›ç»“æœï¼Œæ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€"
        )
        
        config = get_config()
        sandbox_config = SandboxConfig(
            timeout=config.sandbox_timeout,
            memory_limit=config.sandbox_memory_limit,
            cpu_limit=config.sandbox_cpu_limit,
            network_access=config.sandbox_network_access,
            file_system_access=config.sandbox_file_system_access,
            allowed_imports=config.allowed_imports,
            blocked_imports=config.blocked_imports
        )
        
        self.sandbox = DockerSandbox(sandbox_config)
        self._execution_count = 0
    
    @property
    def schema(self) -> Dict[str, Any]:
        """å·¥å…·å‚æ•°æ¨¡å¼"""
        return {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "è¦æ‰§è¡Œçš„ä»£ç "
                },
                "language": {
                    "type": "string",
                    "description": "ç¼–ç¨‹è¯­è¨€",
                    "enum": ["python", "javascript", "java", "go", "bash"],
                    "default": "python"
                },
                "session_id": {
                    "type": "string",
                    "description": "ä¼šè¯IDï¼ˆå¯é€‰ï¼Œç”¨äºä¿æŒçŠ¶æ€ï¼‰"
                }
            },
            "required": ["code"]
        }
    
    async def execute(self, **kwargs) -> ToolResult:
        """æ‰§è¡Œä»£ç """
        try:
            # å‚æ•°éªŒè¯
            validation_result = self.validate_input(**kwargs)
            if validation_result is not True:
                return ToolResult.invalid_input(validation_result)
            
            code = kwargs.get("code", "")
            language = kwargs.get("language", "python")
            session_id = kwargs.get("session_id")
            
            # ä»£ç å®‰å…¨æ£€æŸ¥
            if not self._is_code_safe(code, language):
                return ToolResult.error(
                    "ä»£ç åŒ…å«ä¸å®‰å…¨çš„æ“ä½œ",
                    metadata={"security_check": "failed"}
                )
            
            # æ‰§è¡Œä»£ç 
            logger.info(f"æ‰§è¡Œ{language}ä»£ç ï¼Œä¼šè¯ID: {session_id}")
            result = await self.sandbox.execute(code, language, session_id)
            
            self._execution_count += 1
            
            if result.success:
                return ToolResult.success(
                    content={
                        "output": result.output,
                        "execution_time": result.execution_time,
                        "language": language,
                        "session_id": result.session_id
                    },
                    execution_time=result.execution_time,
                    metadata={
                        "exit_code": result.exit_code,
                        "memory_usage": result.memory_usage,
                        "execution_count": self._execution_count
                    }
                )
            else:
                return ToolResult.error(
                    result.error,
                    execution_time=result.execution_time,
                    metadata={
                        "exit_code": result.exit_code,
                        "status": result.status.value
                    }
                )
                
        except Exception as e:
            logger.error(f"ä»£ç æ‰§è¡Œå·¥å…·å¼‚å¸¸: {e}")
            return ToolResult.error(f"æ‰§è¡Œå¼‚å¸¸: {str(e)}")
    
    def validate_input(self, **kwargs) -> Union[bool, str]:
        """éªŒè¯è¾“å…¥å‚æ•°"""
        code = kwargs.get("code")
        if not code or not isinstance(code, str):
            return "ä»£ç ä¸èƒ½ä¸ºç©ºä¸”å¿…é¡»æ˜¯å­—ç¬¦ä¸²"
        
        if len(code) > 10000:  # 10KBé™åˆ¶
            return "ä»£ç é•¿åº¦ä¸èƒ½è¶…è¿‡10KB"
        
        language = kwargs.get("language", "python")
        supported_languages = ["python", "javascript", "java", "go", "bash"]
        if language not in supported_languages:
            return f"ä¸æ”¯æŒçš„è¯­è¨€: {language}ï¼Œæ”¯æŒçš„è¯­è¨€: {supported_languages}"
        
        return True
    
    def _is_code_safe(self, code: str, language: str) -> bool:
        """åŸºç¡€ä»£ç å®‰å…¨æ£€æŸ¥"""
        # å±é™©å…³é”®è¯æ£€æŸ¥
        dangerous_keywords = {
            'python': [
                'import os', 'import subprocess', 'import socket',
                'import urllib', 'import requests', '__import__',
                'eval(', 'exec(', 'compile(', 'open('
            ],
            'javascript': [
                'require(', 'import(', 'fetch(', 'XMLHttpRequest',
                'process.', 'child_process', 'fs.', 'net.'
            ],
            'java': [
                'Runtime.', 'ProcessBuilder', 'System.exit',
                'File(', 'FileInputStream', 'Socket('
            ],
            'bash': [
                'rm -rf', 'sudo', 'su -', 'chmod +x',
                'wget', 'curl', 'nc ', 'netcat'
            ]
        }
        
        if language in dangerous_keywords:
            for keyword in dangerous_keywords[language]:
                if keyword in code:
                    logger.warning(f"æ£€æµ‹åˆ°å±é™©å…³é”®è¯: {keyword}")
                    return False
        
        return True
    
    async def cleanup(self) -> None:
        """æ¸…ç†èµ„æº"""
        if hasattr(self, 'sandbox'):
            await self.sandbox.cleanup()
```

#### 3.2 ä¼šè¯ç®¡ç†å·¥å…·

**tools/session_manager.py**:
```python
"""
ä¼šè¯ç®¡ç†å·¥å…·

ç®¡ç†ä»£ç æ‰§è¡Œä¼šè¯çš„ç”Ÿå‘½å‘¨æœŸã€‚
"""

import asyncio
import time
from typing import Dict, Any, List, Optional, Union

from practical6.tools.base import BaseTool, ToolResult, ToolResultStatus
from ..sandbox.docker_sandbox import DockerSandbox
from ..utils.logger import get_logger

logger = get_logger(__name__)


class SessionManagerTool(BaseTool):
    """ä¼šè¯ç®¡ç†å·¥å…·"""
    
    def __init__(self, sandbox: DockerSandbox):
        super().__init__(
            name="session_manager",
            description="ç®¡ç†ä»£ç æ‰§è¡Œä¼šè¯ï¼ŒåŒ…æ‹¬åˆ›å»ºã€é”€æ¯å’ŒæŸ¥è¯¢ä¼šè¯"
        )
        self.sandbox = sandbox
    
    @property
    def schema(self) -> Dict[str, Any]:
        """å·¥å…·å‚æ•°æ¨¡å¼"""
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "æ“ä½œç±»å‹",
                    "enum": ["create", "destroy", "list", "info"]
                },
                "session_id": {
                    "type": "string",
                    "description": "ä¼šè¯IDï¼ˆdestroyå’Œinfoæ“ä½œéœ€è¦ï¼‰"
                }
            },
            "required": ["action"]
        }
    
    async def execute(self, **kwargs) -> ToolResult:
        """æ‰§è¡Œä¼šè¯ç®¡ç†æ“ä½œ"""
        try:
            validation_result = self.validate_input(**kwargs)
            if validation_result is not True:
                return ToolResult.invalid_input(validation_result)
            
            action = kwargs.get("action")
            session_id = kwargs.get("session_id")
            
            if action == "create":
                return await self._create_session()
            elif action == "destroy":
                return await self._destroy_session(session_id)
            elif action == "list":
                return await self._list_sessions()
            elif action == "info":
                return await self._get_session_info(session_id)
            else:
                return ToolResult.error(f"æœªçŸ¥æ“ä½œ: {action}")
                
        except Exception as e:
            logger.error(f"ä¼šè¯ç®¡ç†å·¥å…·å¼‚å¸¸: {e}")
            return ToolResult.error(f"æ“ä½œå¼‚å¸¸: {str(e)}")
    
    async def _create_session(self) -> ToolResult:
        """åˆ›å»ºæ–°ä¼šè¯"""
        session_id = await self.sandbox.create_session()
        return ToolResult.success({
            "session_id": session_id,
            "message": "ä¼šè¯åˆ›å»ºæˆåŠŸ"
        })
    
    async def _destroy_session(self, session_id: str) -> ToolResult:
        """é”€æ¯ä¼šè¯"""
        if not session_id:
            return ToolResult.invalid_input("session_idä¸èƒ½ä¸ºç©º")
        
        success = await self.sandbox.destroy_session(session_id)
        if success:
            return ToolResult.success({
                "session_id": session_id,
                "message": "ä¼šè¯é”€æ¯æˆåŠŸ"
            })
        else:
            return ToolResult.error(f"ä¼šè¯ä¸å­˜åœ¨: {session_id}")
    
    async def _list_sessions(self) -> ToolResult:
        """åˆ—å‡ºæ‰€æœ‰ä¼šè¯"""
        sessions = await self.sandbox.list_sessions()
        return ToolResult.success({
            "sessions": sessions,
            "count": len(sessions)
        })
    
    async def _get_session_info(self, session_id: str) -> ToolResult:
        """è·å–ä¼šè¯ä¿¡æ¯"""
        if not session_id:
            return ToolResult.invalid_input("session_idä¸èƒ½ä¸ºç©º")
        
        if session_id in self.sandbox.sessions:
            session_info = self.sandbox.sessions[session_id].copy()
            session_info["session_id"] = session_id
            session_info["age"] = time.time() - session_info["created_at"]
            return ToolResult.success(session_info)
        else:
            return ToolResult.error(f"ä¼šè¯ä¸å­˜åœ¨: {session_id}")
    
    def validate_input(self, **kwargs) -> Union[bool, str]:
        """éªŒè¯è¾“å…¥å‚æ•°"""
        action = kwargs.get("action")
        if not action:
            return "actionå‚æ•°ä¸èƒ½ä¸ºç©º"
        
        valid_actions = ["create", "destroy", "list", "info"]
        if action not in valid_actions:
            return f"æ— æ•ˆçš„action: {action}ï¼Œæœ‰æ•ˆå€¼: {valid_actions}"
        
        if action in ["destroy", "info"]:
            session_id = kwargs.get("session_id")
            if not session_id:
                return f"{action}æ“ä½œéœ€è¦session_idå‚æ•°"
        
        return True
```

### é˜¶æ®µ4ï¼šä»£ç†é›†æˆ (ç¬¬8-9å¤©)

#### 4.1 æ²™ç®±ä»£ç†å®ç°

**agent/sandbox_agent.py**:
```python
"""
æ²™ç®±ä»£ç†

é›†æˆæ²™ç®±æ‰§è¡Œç¯å¢ƒçš„æ™ºèƒ½ä»£ç†ï¼Œæ”¯æŒç¼–ç¨‹é—®é¢˜è§£å†³ã€‚
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass

# ç»§æ‰¿é¡¹ç›®6çš„å¤šæ¨¡æ€ä»£ç†
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', 'practical6'))

from practical6.agent.multimodal_agent import MultimodalAgent
from practical6.tools.manager import ToolManager
from practical6.utils.config import Config as BaseConfig

from ..sandbox.docker_sandbox import DockerSandbox
from ..sandbox.base import SandboxConfig
from ..tools.code_executor import CodeExecutorTool
from ..tools.session_manager import SessionManagerTool
from ..utils.config import get_config
from ..utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class CodingTask:
    """ç¼–ç¨‹ä»»åŠ¡æ•°æ®ç±»"""
    description: str
    language: str = "python"
    requirements: List[str] = None
    test_cases: List[Dict[str, Any]] = None
    session_id: Optional[str] = None


class SandboxAgent(MultimodalAgent):
    """æ²™ç®±ä»£ç†"""
    
    def __init__(self, config: BaseConfig, max_steps: int = 20):
        super().__init__(config, max_steps)
        
        # åˆå§‹åŒ–æ²™ç®±
        sandbox_config = SandboxConfig(
            timeout=getattr(config, 'sandbox_timeout', 30),
            memory_limit=getattr(config, 'sandbox_memory_limit', 512),
            cpu_limit=getattr(config, 'sandbox_cpu_limit', 1.0),
            network_access=getattr(config, 'sandbox_network_access', False),
            file_system_access=getattr(config, 'sandbox_file_system_access', False)
        )
        
        self.sandbox = DockerSandbox(sandbox_config)
        
        # æ³¨å†Œæ²™ç®±å·¥å…·
        self._register_sandbox_tools()
        
        # ç¼–ç¨‹ä»»åŠ¡å†å²
        self.coding_history: List[CodingTask] = []
    
    def _register_sandbox_tools(self) -> None:
        """æ³¨å†Œæ²™ç®±ç›¸å…³å·¥å…·"""
        # ä»£ç æ‰§è¡Œå·¥å…·
        code_executor = CodeExecutorTool()
        self.tool_manager.register_tool(code_executor)
        
        # ä¼šè¯ç®¡ç†å·¥å…·
        session_manager = SessionManagerTool(self.sandbox)
        self.tool_manager.register_tool(session_manager)
        
        logger.info("æ²™ç®±å·¥å…·æ³¨å†Œå®Œæˆ")
    
    async def solve_coding_problem(self, problem_description: str, 
                                 language: str = "python",
                                 requirements: List[str] = None,
                                 test_cases: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """è§£å†³ç¼–ç¨‹é—®é¢˜"""
        
        # åˆ›å»ºç¼–ç¨‹ä»»åŠ¡
        task = CodingTask(
            description=problem_description,
            language=language,
            requirements=requirements or [],
            test_cases=test_cases or []
        )
        
        # æ„å»ºå¢å¼ºæç¤º
        enhanced_prompt = self._build_coding_prompt(task)
        
        # åˆ›å»ºä¼šè¯
        session_result = await self.tool_manager.execute_tool("session_manager", action="create")
        if session_result.is_success:
            task.session_id = session_result.content["session_id"]
            logger.info(f"ä¸ºç¼–ç¨‹ä»»åŠ¡åˆ›å»ºä¼šè¯: {task.session_id}")
        
        try:
            # æ‰§è¡Œæ¨ç†
            result = await self.solve_multimodal(enhanced_prompt, task_type="coding")
            
            # è®°å½•ä»»åŠ¡å†å²
            self.coding_history.append(task)
            
            # å¢å¼ºç»“æœä¿¡æ¯
            result["task_info"] = {
                "language": task.language,
                "session_id": task.session_id,
                "requirements": task.requirements,
                "test_cases_count": len(task.test_cases)
            }
            
            return result
            
        finally:
            # æ¸…ç†ä¼šè¯ï¼ˆå¯é€‰ï¼‰
            if task.session_id:
                await self.tool_manager.execute_tool(
                    "session_manager", 
                    action="destroy", 
                    session_id=task.session_id
                )
    
    def _build_coding_prompt(self, task: CodingTask) -> str:
        """æ„å»ºç¼–ç¨‹ä»»åŠ¡æç¤º"""
        prompt_parts = [
            f"ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„{task.language}ç¼–ç¨‹åŠ©æ‰‹ï¼Œéœ€è¦è§£å†³ä»¥ä¸‹ç¼–ç¨‹é—®é¢˜ï¼š",
            f"\né—®é¢˜æè¿°ï¼š{task.description}",
            f"\nç¼–ç¨‹è¯­è¨€ï¼š{task.language}"
        ]
        
        if task.requirements:
            prompt_parts.append(f"\nè¦æ±‚ï¼š")
            for i, req in enumerate(task.requirements, 1):
                prompt_parts.append(f"{i}. {req}")
        
        if task.test_cases:
            prompt_parts.append(f"\næµ‹è¯•ç”¨ä¾‹ï¼š")
            for i, test_case in enumerate(task.test_cases, 1):
                input_data = test_case.get("input", "")
                expected_output = test_case.get("output", "")
                prompt_parts.append(f"æµ‹è¯•{i}: è¾“å…¥={input_data}, æœŸæœ›è¾“å‡º={expected_output}")
        
        prompt_parts.extend([
            f"\nå¯ç”¨å·¥å…·ï¼š",
            f"1. code_executor - æ‰§è¡Œ{task.language}ä»£ç å¹¶è·å–ç»“æœ",
            f"2. session_manager - ç®¡ç†ä»£ç æ‰§è¡Œä¼šè¯",
            f"\nè¯·æŒ‰ä»¥ä¸‹æ­¥éª¤è§£å†³é—®é¢˜ï¼š",
            f"1. åˆ†æé—®é¢˜éœ€æ±‚",
            f"2. è®¾è®¡è§£å†³æ–¹æ¡ˆ",
            f"3. ç¼–å†™ä»£ç å®ç°",
            f"4. æ‰§è¡Œä»£ç éªŒè¯",
            f"5. æ ¹æ®ç»“æœä¼˜åŒ–ä»£ç ",
            f"6. æä¾›æœ€ç»ˆè§£å†³æ–¹æ¡ˆ",
            f"\næ³¨æ„ï¼šè¯·ç¡®ä¿ä»£ç çš„æ­£ç¡®æ€§ã€æ•ˆç‡å’Œå¯è¯»æ€§ã€‚"
        ])
        
        return "\n".join(prompt_parts)
    
    async def execute_code_with_tests(self, code: str, language: str = "python",
                                    test_cases: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """æ‰§è¡Œä»£ç å¹¶è¿è¡Œæµ‹è¯•ç”¨ä¾‹"""
        results = {
            "code_execution": None,
            "test_results": [],
            "all_tests_passed": True
        }
        
        # æ‰§è¡Œä¸»ä»£ç 
        exec_result = await self.tool_manager.execute_tool(
            "code_executor",
            code=code,
            language=language
        )
        results["code_execution"] = exec_result.to_dict()
        
        # è¿è¡Œæµ‹è¯•ç”¨ä¾‹
        if test_cases and exec_result.is_success:
            for i, test_case in enumerate(test_cases):
                test_code = self._generate_test_code(code, test_case, language)
                test_result = await self.tool_manager.execute_tool(
                    "code_executor",
                    code=test_code,
                    language=language
                )
                
                test_passed = self._evaluate_test_result(
                    test_result, 
                    test_case.get("output", "")
                )
                
                results["test_results"].append({
                    "test_case": i + 1,
                    "input": test_case.get("input", ""),
                    "expected": test_case.get("output", ""),
                    "actual": test_result.content.get("output", "") if test_result.is_success else "ERROR",
                    "passed": test_passed,
                    "execution_result": test_result.to_dict()
                })
                
                if not test_passed:
                    results["all_tests_passed"] = False
        
        return results
    
    def _generate_test_code(self, original_code: str, test_case: Dict[str, Any], 
                          language: str) -> str:
        """ç”Ÿæˆæµ‹è¯•ä»£ç """
        if language == "python":
            return f"""
{original_code}

# æµ‹è¯•ç”¨ä¾‹
test_input = {repr(test_case.get("input", ""))}
try:
    result = main(test_input) if 'main' in globals() else eval(test_input)
    print(result)
except Exception as e:
    print(f"ERROR: {{e}}")
"""
        elif language == "javascript":
            return f"""
{original_code}

// æµ‹è¯•ç”¨ä¾‹
const testInput = {test_case.get("input", "")};
try {{
    const result = typeof main === 'function' ? main(testInput) : eval(testInput);
    console.log(result);
}} catch (e) {{
    console.log(`ERROR: ${{e}}`);
}}
"""
        else:
            return original_code
    
    def _evaluate_test_result(self, test_result, expected_output: str) -> bool:
        """è¯„ä¼°æµ‹è¯•ç»“æœ"""
        if not test_result.is_success:
            return False
        
        actual_output = test_result.content.get("output", "").strip()
        expected_output = str(expected_output).strip()
        
        return actual_output == expected_output
    
    async def get_sandbox_stats(self) -> Dict[str, Any]:
        """è·å–æ²™ç®±ç»Ÿè®¡ä¿¡æ¯"""
        stats = self.sandbox.get_stats()
        sessions = await self.sandbox.list_sessions()
        
        return {
            "execution_stats": stats,
            "active_sessions": len(sessions),
            "coding_tasks_completed": len(self.coding_history),
            "supported_languages": list(self.sandbox.language_images.keys())
        }
    
    async def cleanup(self) -> None:
        """æ¸…ç†èµ„æº"""
        await super().cleanup()
        if hasattr(self, 'sandbox'):
            await self.sandbox.cleanup()
        logger.info("æ²™ç®±ä»£ç†èµ„æºæ¸…ç†å®Œæˆ")


# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """æ¼”ç¤ºæ²™ç®±ä»£ç†çš„ä½¿ç”¨"""
    config = get_config()
    agent = SandboxAgent(config)
    
    # ç¤ºä¾‹ç¼–ç¨‹é—®é¢˜
    problems = [
        {
            "description": "ç¼–å†™ä¸€ä¸ªå‡½æ•°è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹",
            "language": "python",
            "requirements": [
                "ä½¿ç”¨é€’å½’å®ç°",
                "å¤„ç†è¾¹ç•Œæƒ…å†µï¼ˆn <= 0ï¼‰",
                "è¿”å›æ•´æ•°ç»“æœ"
            ],
            "test_cases": [
                {"input": "0", "output": "0"},
                {"input": "1", "output": "1"},
                {"input": "5", "output": "5"},
                {"input": "10", "output": "55"}
            ]
        },
        {
            "description": "å®ç°ä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨ï¼Œæ”¯æŒåŠ å‡ä¹˜é™¤",
            "language": "javascript",
            "requirements": [
                "æ”¯æŒåŸºæœ¬å››åˆ™è¿ç®—",
                "å¤„ç†é™¤é›¶é”™è¯¯",
                "è¿”å›æ•°å€¼ç»“æœ"
            ],
            "test_cases": [
                {"input": "2 + 3", "output": "5"},
                {"input": "10 - 4", "output": "6"},
                {"input": "3 * 7", "output": "21"},
                {"input": "15 / 3", "output": "5"}
            ]
        }
    ]
    
    for i, problem in enumerate(problems, 1):
        print(f"\n{'='*60}")
        print(f"ç¼–ç¨‹é—®é¢˜ {i}: {problem['description']}")
        print(f"è¯­è¨€: {problem['language']}")
        print('='*60)
        
        try:
            result = await agent.solve_coding_problem(
                problem["description"],
                problem["language"],
                problem["requirements"],
                problem["test_cases"]
            )
            
            print(f"è§£å†³æ–¹æ¡ˆ: {result.get('final_answer', 'æœªæ‰¾åˆ°è§£å†³æ–¹æ¡ˆ')}")
            print(f"æ‰§è¡Œæ­¥éª¤: {len(result.get('steps', []))}")
            print(f"æ€»è€—æ—¶: {result.get('total_time', 0):.2f}ç§’")
            
        except Exception as e:
            print(f"æ‰§è¡Œå¤±è´¥: {e}")
    
    # æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    stats = await agent.get_sandbox_stats()
    print(f"\n{'='*60}")
    print("æ²™ç®±ç»Ÿè®¡ä¿¡æ¯:")
    print(f"æ€»æ‰§è¡Œæ¬¡æ•°: {stats['execution_stats']['total_executions']}")
    print(f"æˆåŠŸæ‰§è¡Œ: {stats['execution_stats']['successful_executions']}")
    print(f"æ´»è·ƒä¼šè¯: {stats['active_sessions']}")
    print(f"å®Œæˆä»»åŠ¡: {stats['coding_tasks_completed']}")
    print('='*60)
    
    # æ¸…ç†èµ„æº
    await agent.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
```

### é˜¶æ®µ5ï¼šæµ‹è¯•å’Œæ–‡æ¡£ (ç¬¬10å¤©)

#### 5.1 æµ‹è¯•æ¡†æ¶

**tests/test_sandbox.py**:
```python
"""
æ²™ç®±æµ‹è¯•

æµ‹è¯•æ²™ç®±çš„åŸºæœ¬åŠŸèƒ½å’Œå®‰å…¨æ€§ã€‚
"""

import pytest
import asyncio
from ..sandbox.docker_sandbox import DockerSandbox
from ..sandbox.base import SandboxConfig, ExecutionStatus


@pytest.fixture
async def sandbox():
    """æ²™ç®±æµ‹è¯•å¤¹å…·"""
    config = SandboxConfig(
        timeout=10,
        memory_limit=128,
        cpu_limit=0.5,
        network_access=False
    )
    sandbox = DockerSandbox(config)
    yield sandbox
    await sandbox.cleanup()


@pytest.mark.asyncio
async def test_python_execution(sandbox):
    """æµ‹è¯•Pythonä»£ç æ‰§è¡Œ"""
    code = "print('Hello, World!')"
    result = await sandbox.execute(code, "python")
    
    assert result.success
    assert "Hello, World!" in result.output
    assert result.execution_time > 0


@pytest.mark.asyncio
async def test_javascript_execution(sandbox):
    """æµ‹è¯•JavaScriptä»£ç æ‰§è¡Œ"""
    code = "console.log('Hello, JavaScript!');"
    result = await sandbox.execute(code, "javascript")
    
    assert result.success
    assert "Hello, JavaScript!" in result.output


@pytest.mark.asyncio
async def test_timeout_handling(sandbox):
    """æµ‹è¯•è¶…æ—¶å¤„ç†"""
    code = """
import time
time.sleep(15)  # è¶…è¿‡10ç§’è¶…æ—¶é™åˆ¶
print('This should not print')
"""
    result = await sandbox.execute(code, "python")
    
    assert not result.success
    assert result.status == ExecutionStatus.TIMEOUT


@pytest.mark.asyncio
async def test_memory_limit(sandbox):
    """æµ‹è¯•å†…å­˜é™åˆ¶"""
    code = """
# å°è¯•åˆ†é…å¤§é‡å†…å­˜
data = []
for i in range(1000000):
    data.append([0] * 1000)
"""
    result = await sandbox.execute(code, "python")
    
    # åº”è¯¥å› å†…å­˜é™åˆ¶è€Œå¤±è´¥
    assert not result.success


@pytest.mark.asyncio
async def test_session_management(sandbox):
    """æµ‹è¯•ä¼šè¯ç®¡ç†"""
    # åˆ›å»ºä¼šè¯
    session_id = await sandbox.create_session()
    assert session_id
    
    # åˆ—å‡ºä¼šè¯
    sessions = await sandbox.list_sessions()
    assert session_id in sessions
    
    # é”€æ¯ä¼šè¯
    success = await sandbox.destroy_session(session_id)
    assert success
    
    # éªŒè¯ä¼šè¯å·²é”€æ¯
    sessions = await sandbox.list_sessions()
    assert session_id not in sessions


@pytest.mark.asyncio
async def test_security_isolation(sandbox):
    """æµ‹è¯•å®‰å…¨éš”ç¦»"""
    # å°è¯•è®¿é—®æ–‡ä»¶ç³»ç»Ÿ
    code = """
import os
try:
    os.listdir('/')
    print('File system access succeeded')
except:
    print('File system access denied')
"""
    result = await sandbox.execute(code, "python")
    
    # åº”è¯¥è¢«å®‰å…¨é™åˆ¶é˜»æ­¢
    assert "access denied" in result.output.lower() or not result.success
```

#### 5.2 æ¼”ç¤ºç¨‹åº

**demo.py**:
```python
"""
æ²™ç®±ä»£ç†æ¼”ç¤ºç¨‹åº

å±•ç¤ºæ²™ç®±ä»£ç†çš„å„ç§åŠŸèƒ½ã€‚
"""

import asyncio
import logging
from utils.config import get_config
from utils.logger import setup_logger
from agent.sandbox_agent import SandboxAgent


async def demo_basic_execution():
    """æ¼”ç¤ºåŸºæœ¬ä»£ç æ‰§è¡Œ"""
    print("\n" + "="*60)
    print("æ¼”ç¤º1: åŸºæœ¬ä»£ç æ‰§è¡Œ")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    # Pythonä»£ç æ‰§è¡Œ
    python_code = """
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

for i in range(10):
    print(f"fib({i}) = {fibonacci(i)}")
"""
    
    result = await agent.tool_manager.execute_tool(
        "code_executor",
        code=python_code,
        language="python"
    )
    
    print("Pythonæ‰§è¡Œç»“æœ:")
    print(f"æˆåŠŸ: {result.is_success}")
    print(f"è¾“å‡º: {result.content.get('output', '') if result.is_success else result.error_message}")
    print(f"æ‰§è¡Œæ—¶é—´: {result.execution_time:.2f}ç§’")
    
    await agent.cleanup()


async def demo_coding_problem_solving():
    """æ¼”ç¤ºç¼–ç¨‹é—®é¢˜è§£å†³"""
    print("\n" + "="*60)
    print("æ¼”ç¤º2: ç¼–ç¨‹é—®é¢˜è§£å†³")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    problem = {
        "description": "ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡",
        "language": "python",
        "requirements": [
            "å¿½ç•¥å¤§å°å†™",
            "å¿½ç•¥ç©ºæ ¼å’Œæ ‡ç‚¹ç¬¦å·",
            "è¿”å›å¸ƒå°”å€¼"
        ],
        "test_cases": [
            {"input": "'racecar'", "output": "True"},
            {"input": "'A man a plan a canal Panama'", "output": "True"},
            {"input": "'hello'", "output": "False"}
        ]
    }
    
    result = await agent.solve_coding_problem(
        problem["description"],
        problem["language"],
        problem["requirements"],
        problem["test_cases"]
    )
    
    print(f"é—®é¢˜: {problem['description']}")
    print(f"è§£å†³æ–¹æ¡ˆ: {result.get('final_answer', 'æœªæ‰¾åˆ°è§£å†³æ–¹æ¡ˆ')}")
    print(f"æ‰§è¡Œæ­¥éª¤: {len(result.get('steps', []))}")
    print(f"æ€»è€—æ—¶: {result.get('total_time', 0):.2f}ç§’")
    
    await agent.cleanup()


async def demo_multi_language_support():
    """æ¼”ç¤ºå¤šè¯­è¨€æ”¯æŒ"""
    print("\n" + "="*60)
    print("æ¼”ç¤º3: å¤šè¯­è¨€æ”¯æŒ")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    # ä¸åŒè¯­è¨€çš„Hello World
    examples = [
        {
            "language": "python",
            "code": "print('Hello from Python!')"
        },
        {
            "language": "javascript",
            "code": "console.log('Hello from JavaScript!');"
        },
        {
            "language": "bash",
            "code": "echo 'Hello from Bash!'"
        }
    ]
    
    for example in examples:
        print(f"\n{example['language'].upper()}:")
        result = await agent.tool_manager.execute_tool(
            "code_executor",
            code=example["code"],
            language=example["language"]
        )
        
        if result.is_success:
            print(f"è¾“å‡º: {result.content.get('output', '')}")
        else:
            print(f"é”™è¯¯: {result.error_message}")
    
    await agent.cleanup()


async def demo_session_management():
    """æ¼”ç¤ºä¼šè¯ç®¡ç†"""
    print("\n" + "="*60)
    print("æ¼”ç¤º4: ä¼šè¯ç®¡ç†")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    # åˆ›å»ºä¼šè¯
    session_result = await agent.tool_manager.execute_tool(
        "session_manager",
        action="create"
    )
    
    if session_result.is_success:
        session_id = session_result.content["session_id"]
        print(f"åˆ›å»ºä¼šè¯: {session_id}")
        
        # åœ¨ä¼šè¯ä¸­æ‰§è¡Œä»£ç 
        code1 = "x = 42\nprint(f'x = {x}')"
        result1 = await agent.tool_manager.execute_tool(
            "code_executor",
            code=code1,
            language="python",
            session_id=session_id
        )
        print(f"ç¬¬ä¸€æ¬¡æ‰§è¡Œ: {result1.content.get('output', '') if result1.is_success else result1.error_message}")
        
        # åœ¨åŒä¸€ä¼šè¯ä¸­ä½¿ç”¨ä¹‹å‰çš„å˜é‡
        code2 = "y = x * 2\nprint(f'y = {y}')"
        result2 = await agent.tool_manager.execute_tool(
            "code_executor",
            code=code2,
            language="python",
            session_id=session_id
        )
        print(f"ç¬¬äºŒæ¬¡æ‰§è¡Œ: {result2.content.get('output', '') if result2.is_success else result2.error_message}")
        
        # é”€æ¯ä¼šè¯
        destroy_result = await agent.tool_manager.execute_tool(
            "session_manager",
            action="destroy",
            session_id=session_id
        )
        print(f"é”€æ¯ä¼šè¯: {destroy_result.is_success}")
    
    await agent.cleanup()


async def main():
    """ä¸»æ¼”ç¤ºå‡½æ•°"""
    # è®¾ç½®æ—¥å¿—
    setup_logger()
    
    print("æ²™ç®±ä»£ç†æ¼”ç¤ºç¨‹åº")
    print("="*60)
    
    try:
        await demo_basic_execution()
        await demo_coding_problem_solving()
        await demo_multi_language_support()
        await demo_session_management()
        
        print("\n" + "="*60)
        print("æ‰€æœ‰æ¼”ç¤ºå®Œæˆï¼")
        print("="*60)
        
    except Exception as e:
        logging.error(f"æ¼”ç¤ºè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        print(f"é”™è¯¯: {e}")


if __name__ == "__main__":
    asyncio.run(main())
```

## å­¦ä¹ è¦ç‚¹æ€»ç»“

### ğŸ”§ æŠ€æœ¯è¦ç‚¹

1. **Dockerå®¹å™¨æŠ€æœ¯**
   - å®¹å™¨åˆ›å»ºå’Œç®¡ç†
   - èµ„æºé™åˆ¶é…ç½®
   - å®‰å…¨éš”ç¦»æœºåˆ¶
   - é•œåƒç®¡ç†å’Œä¼˜åŒ–

2. **å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼**
   - async/awaitè¯­æ³•
   - å¹¶å‘æ‰§è¡Œæ§åˆ¶
   - èµ„æºç®¡ç†å’Œæ¸…ç†
   - å¼‚å¸¸å¤„ç†æœºåˆ¶

3. **å®‰å…¨ç¼–ç¨‹å®è·µ**
   - è¾“å…¥éªŒè¯å’Œè¿‡æ»¤
   - æƒé™æ§åˆ¶å’Œéš”ç¦»
   - èµ„æºé™åˆ¶å’Œç›‘æ§
   - å®‰å…¨å®¡è®¡å’Œæ—¥å¿—

4. **æ¶æ„è®¾è®¡æ¨¡å¼**
   - æŠ½è±¡åŸºç±»è®¾è®¡
   - ç­–ç•¥æ¨¡å¼åº”ç”¨
   - å·¥å‚æ¨¡å¼å®ç°
   - ä¾èµ–æ³¨å…¥åŸç†

### ğŸ¯ ä¸OpenManusçš„å¯¹åº”å…³ç³»

1. **ä»£ç æ‰§è¡Œç¯å¢ƒ**: å¯¹åº”OpenManusçš„å®‰å…¨ä»£ç æ‰§è¡ŒåŠŸèƒ½
2. **å¤šè¯­è¨€æ”¯æŒ**: å¯¹åº”OpenManusçš„å¤šè¯­è¨€ä»£ç†èƒ½åŠ›
3. **èµ„æºç®¡ç†**: å¯¹åº”OpenManusçš„èµ„æºæ§åˆ¶æœºåˆ¶
4. **å®‰å…¨éš”ç¦»**: å¯¹åº”OpenManusçš„å®‰å…¨æ²™ç®±è®¾è®¡

### ğŸ“š è¿›é˜¶å­¦ä¹ æ–¹å‘

1. **å®¹å™¨ç¼–æ’**: Kubernetesã€Docker Swarm
2. **å¾®æœåŠ¡æ¶æ„**: æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡
3. **å®‰å…¨åŠ å›º**: SELinuxã€AppArmorã€seccomp
4. **æ€§èƒ½ä¼˜åŒ–**: å®¹å™¨æ€§èƒ½è°ƒä¼˜ã€èµ„æºæ± ç®¡ç†
5. **ç›‘æ§å‘Šè­¦**: Prometheusã€Grafanaé›†æˆ

## å®æ–½æ—¶é—´è¡¨

| é˜¶æ®µ | æ—¶é—´ | ä¸»è¦ä»»åŠ¡ | äº¤ä»˜ç‰© |
|------|------|----------|--------|
| é˜¶æ®µ1 | ç¬¬1-2å¤© | åŸºç¡€è®¾æ–½æ­å»º | é¡¹ç›®ç»“æ„ã€é…ç½®ç³»ç»Ÿ |
| é˜¶æ®µ2 | ç¬¬3-5å¤© | æ²™ç®±æ ¸å¿ƒå®ç° | åŸºç±»ã€Dockerå®ç° |
| é˜¶æ®µ3 | ç¬¬6-7å¤© | å·¥å…·ç³»ç»Ÿé›†æˆ | æ‰§è¡Œå·¥å…·ã€ä¼šè¯ç®¡ç† |
| é˜¶æ®µ4 | ç¬¬8-9å¤© | ä»£ç†é›†æˆ | æ²™ç®±ä»£ç†ã€é—®é¢˜è§£å†³ |
| é˜¶æ®µ5 | ç¬¬10å¤© | æµ‹è¯•å’Œæ–‡æ¡£ | æµ‹è¯•ç”¨ä¾‹ã€æ¼”ç¤ºç¨‹åº |

## æ€»ç»“

é¡¹ç›®7é€šè¿‡å®ç°å®‰å…¨çš„æ²™ç®±æ‰§è¡Œç¯å¢ƒï¼Œä¸ºAIä»£ç†æä¾›äº†å¼ºå¤§çš„ä»£ç æ‰§è¡Œèƒ½åŠ›ã€‚é€šè¿‡Dockerå®¹å™¨æŠ€æœ¯ï¼Œæˆ‘ä»¬å®ç°äº†ï¼š

1. **å®‰å…¨éš”ç¦»**: ä½¿ç”¨Dockerå®¹å™¨æä¾›å®Œå…¨éš”ç¦»çš„æ‰§è¡Œç¯å¢ƒ
2. **å¤šè¯­è¨€æ”¯æŒ**: æ”¯æŒPythonã€JavaScriptã€Javaã€Goã€Bashç­‰å¤šç§è¯­è¨€
3. **èµ„æºæ§åˆ¶**: å®ç°CPUã€å†…å­˜ã€æ—¶é—´ç­‰å¤šç»´åº¦èµ„æºé™åˆ¶
4. **ä»£ç†é›†æˆ**: æ— ç¼é›†æˆåˆ°ReActä»£ç†æ¶æ„ä¸­
5. **ä¼šè¯ç®¡ç†**: æ”¯æŒé•¿æœŸä¼šè¯å’ŒçŠ¶æ€ä¿æŒ

### ğŸš€ æ ¸å¿ƒä»·å€¼

- **å®‰å…¨æ€§**: é€šè¿‡å®¹å™¨éš”ç¦»å’Œæƒé™æ§åˆ¶ï¼Œç¡®ä¿ä»£ç æ‰§è¡Œçš„å®‰å…¨æ€§
- **å¯æ‰©å±•æ€§**: æ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºæ·»åŠ æ–°çš„ç¼–ç¨‹è¯­è¨€æ”¯æŒ
- **æ˜“ç”¨æ€§**: ç®€æ´çš„APIè®¾è®¡ï¼Œä¾¿äºé›†æˆå’Œä½¿ç”¨
- **å¯é æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œèµ„æºæ¸…ç†æœºåˆ¶

### ğŸ“ˆ å­¦ä¹ æ”¶è·

é€šè¿‡é¡¹ç›®7çš„å®æ–½ï¼Œä½ å°†æŒæ¡ï¼š

1. **DockeræŠ€æœ¯æ ˆ**: å®¹å™¨åŒ–åº”ç”¨å¼€å‘å’Œéƒ¨ç½²
2. **å¼‚æ­¥ç¼–ç¨‹**: Pythonå¼‚æ­¥ç¼–ç¨‹çš„æœ€ä½³å®è·µ
3. **å®‰å…¨ç¼–ç¨‹**: ä»£ç æ‰§è¡Œå®‰å…¨å’Œæƒé™æ§åˆ¶
4. **æ¶æ„è®¾è®¡**: å¤§å‹ç³»ç»Ÿçš„æ¨¡å—åŒ–è®¾è®¡
5. **æµ‹è¯•é©±åŠ¨**: å®Œæ•´çš„æµ‹è¯•æ¡†æ¶å’Œæµ‹è¯•ç­–ç•¥

### ğŸ”„ ä¸OpenManusçš„è”ç³»

é¡¹ç›®7æ˜¯OpenManusæ¶æ„ä¸­çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå®ƒä¸ºAIä»£ç†æä¾›äº†ï¼š

- **ä»£ç æ‰§è¡Œèƒ½åŠ›**: è®©ä»£ç†èƒ½å¤Ÿæ‰§è¡Œå’ŒéªŒè¯ä»£ç 
- **å¤šè¯­è¨€æ”¯æŒ**: æ‰©å±•ä»£ç†çš„ç¼–ç¨‹è¯­è¨€å¤„ç†èƒ½åŠ›
- **å®‰å…¨ä¿éšœ**: ç¡®ä¿ä»£ç æ‰§è¡Œçš„å®‰å…¨æ€§å’Œå¯æ§æ€§
- **å·¥å…·ç”Ÿæ€**: ä¸°å¯Œä»£ç†çš„å·¥å…·é›†åˆ

### ğŸ¯ ä¸‹ä¸€æ­¥è®¡åˆ’

å®Œæˆé¡¹ç›®7åï¼Œå»ºè®®ç»§ç»­å­¦ä¹ ï¼š

1. **é¡¹ç›®8**: åˆ†å¸ƒå¼ä»£ç†ç³»ç»Ÿ
2. **é¡¹ç›®9**: ä»£ç†åä½œå’Œé€šä¿¡
3. **é¡¹ç›®10**: ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å’Œç›‘æ§

é€šè¿‡å¾ªåºæ¸è¿›çš„å­¦ä¹ ï¼Œä½ å°†é€æ­¥æŒæ¡æ„å»ºä¼ä¸šçº§AIä»£ç†ç³»ç»Ÿçš„å®Œæ•´æŠ€èƒ½æ ˆã€‚

---

**æ³¨æ„**: æœ¬æ–‡æ¡£æä¾›äº†è¯¦ç»†çš„å®æ–½è®¡åˆ’å’Œä»£ç ç¤ºä¾‹ï¼Œå»ºè®®æŒ‰ç…§é˜¶æ®µé€æ­¥å®æ–½ï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µçš„åŠŸèƒ½éƒ½èƒ½æ­£å¸¸å·¥ä½œåå†è¿›å…¥ä¸‹ä¸€é˜¶æ®µã€‚åœ¨å®æ–½è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´å…·ä½“çš„å®ç°ç»†èŠ‚ï¼Œä½†è¦ä¿æŒæ•´ä½“æ¶æ„çš„ä¸€è‡´æ€§ã€‚