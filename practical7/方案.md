# È°πÁõÆ7ÔºöÊ≤ôÁÆ±ÊâßË°åÁéØÂ¢É - ËØ¶ÁªÜÂºÄÂèëÊñπÊ°à

## È°πÁõÆÊ¶ÇËø∞

Âü∫‰∫éÈ°πÁõÆ6ÁöÑÂ§öÊ®°ÊÄÅ‰ª£ÁêÜÊû∂ÊûÑÔºåÂÆûÁé∞ÂÆâÂÖ®ÁöÑ‰ª£Á†ÅÊâßË°åÁéØÂ¢ÉÔºåÊîØÊåÅÂ§öÁßçÁºñÁ®ãËØ≠Ë®ÄÔºåÊèê‰æõËµÑÊ∫êÈôêÂà∂ÂíåÂÆâÂÖ®ÈöîÁ¶ªÔºåÂπ∂ÈõÜÊàêÂà∞AI‰ª£ÁêÜÂ∑•‰ΩúÊµÅ‰∏≠„ÄÇ

### üéØ È°πÁõÆÁõÆÊ†á

1. **ÂÆâÂÖ®ÈöîÁ¶ª**Ôºö‰ΩøÁî®DockerÂÆπÂô®Êèê‰æõÂÆâÂÖ®ÁöÑ‰ª£Á†ÅÊâßË°åÁéØÂ¢É
2. **Â§öËØ≠Ë®ÄÊîØÊåÅ**ÔºöÊîØÊåÅPython„ÄÅJavaScript„ÄÅJava„ÄÅGoÁ≠â‰∏ªÊµÅÁºñÁ®ãËØ≠Ë®Ä
3. **ËµÑÊ∫êÊéßÂà∂**ÔºöÂÆûÁé∞CPU„ÄÅÂÜÖÂ≠ò„ÄÅÊó∂Èó¥Á≠âËµÑÊ∫êÈôêÂà∂
4. **‰ª£ÁêÜÈõÜÊàê**ÔºöÊó†ÁºùÈõÜÊàêÂà∞Áé∞ÊúâÁöÑReAct‰ª£ÁêÜÊû∂ÊûÑ‰∏≠
5. **‰ºöËØùÁÆ°ÁêÜ**ÔºöÊîØÊåÅÈïøÊúü‰ª£Á†ÅÊâßË°å‰ºöËØùÂíåÁä∂ÊÄÅÁÆ°ÁêÜ

### üèóÔ∏è Êû∂ÊûÑËÆæËÆ°

#### Êï¥‰ΩìÊû∂ÊûÑÂõæ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SandboxAgent                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   ReAct Logic   ‚îÇ  ‚îÇ  Tool Manager   ‚îÇ  ‚îÇ   Config    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Sandbox Tools                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ Code Executor   ‚îÇ  ‚îÇSession Manager  ‚îÇ  ‚îÇ File Manager‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  Sandbox Layer                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  BaseSandbox    ‚îÇ  ‚îÇ DockerSandbox   ‚îÇ  ‚îÇProcessSandbox‚îÇ ‚îÇ
‚îÇ  ‚îÇ  (Abstract)     ‚îÇ  ‚îÇ (Production)    ‚îÇ  ‚îÇ (Development)‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Docker Infrastructure                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇPython Container ‚îÇ  ‚îÇ  JS Container   ‚îÇ  ‚îÇJava Container‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## ËØ¶ÁªÜÂÆûÁé∞ËÆ°Âàí

### Èò∂ÊÆµ1ÔºöÂü∫Á°ÄËÆæÊñΩÊê≠Âª∫ (Á¨¨1-2Â§©)

#### 1.1 È°πÁõÆÁªìÊûÑÂàõÂª∫

```
practical7/
‚îú‚îÄ‚îÄ README.md                    # È°πÁõÆËØ¥ÊòéÊñáÊ°£
‚îú‚îÄ‚îÄ requirements.txt             # ‰æùËµñÂåÖÂàóË°®
‚îú‚îÄ‚îÄ .env.example                # ÁéØÂ¢ÉÂèòÈáèÁ§∫‰æã
‚îú‚îÄ‚îÄ main.py                     # ‰∏ªÁ®ãÂ∫èÂÖ•Âè£
‚îú‚îÄ‚îÄ demo.py                     # ÊºîÁ§∫Á®ãÂ∫è
‚îú‚îÄ‚îÄ ÊñπÊ°à.md                     # Êú¨ÊñáÊ°£
‚îú‚îÄ‚îÄ sandbox/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py                 # Ê≤ôÁÆ±Âü∫Á±ªÂíåÊï∞ÊçÆÊ®°Âûã
‚îÇ   ‚îú‚îÄ‚îÄ docker_sandbox.py       # DockerÊ≤ôÁÆ±ÂÆûÁé∞
‚îÇ   ‚îî‚îÄ‚îÄ process_sandbox.py      # ËøõÁ®ãÊ≤ôÁÆ±ÂÆûÁé∞ÔºàÂºÄÂèëÁî®Ôºâ
‚îú‚îÄ‚îÄ agent/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ sandbox_agent.py        # Ê≤ôÁÆ±‰ª£ÁêÜ
‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ base.py                 # ÁªßÊâøËá™È°πÁõÆ6
‚îÇ   ‚îú‚îÄ‚îÄ manager.py              # ÁªßÊâøËá™È°πÁõÆ6
‚îÇ   ‚îú‚îÄ‚îÄ code_executor.py        # ‰ª£Á†ÅÊâßË°åÂ∑•ÂÖ∑
‚îÇ   ‚îú‚îÄ‚îÄ session_manager.py      # ‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑
‚îÇ   ‚îî‚îÄ‚îÄ file_manager.py         # Êñá‰ª∂ÁÆ°ÁêÜÂ∑•ÂÖ∑
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py               # Êâ©Â±ïÈÖçÁΩÆÁÆ°ÁêÜ
‚îÇ   ‚îú‚îÄ‚îÄ logger.py               # Êó•ÂøóÁ≥ªÁªü
‚îÇ   ‚îî‚îÄ‚îÄ security.py             # ÂÆâÂÖ®Â∑•ÂÖ∑
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_sandbox.py         # Ê≤ôÁÆ±ÊµãËØï
‚îÇ   ‚îú‚îÄ‚îÄ test_agent.py           # ‰ª£ÁêÜÊµãËØï
‚îÇ   ‚îú‚îÄ‚îÄ test_tools.py           # Â∑•ÂÖ∑ÊµãËØï
‚îÇ   ‚îî‚îÄ‚îÄ test_integration.py     # ÈõÜÊàêÊµãËØï
‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îú‚îÄ‚îÄ python/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile          # PythonÊâßË°åÁéØÂ¢É
‚îÇ   ‚îú‚îÄ‚îÄ javascript/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile          # JavaScriptÊâßË°åÁéØÂ¢É
‚îÇ   ‚îî‚îÄ‚îÄ java/
‚îÇ       ‚îî‚îÄ‚îÄ Dockerfile          # JavaÊâßË°åÁéØÂ¢É
‚îî‚îÄ‚îÄ logs/
    ‚îî‚îÄ‚îÄ sandbox.log             # Êó•ÂøóÊñá‰ª∂
```

#### 1.2 ‰æùËµñÁÆ°ÁêÜ

**requirements.txt**:
```txt
# Âü∫Á°Ä‰æùËµñÔºàÁªßÊâøËá™È°πÁõÆ6Ôºâ
openai>=1.0.0
pydantic>=2.0.0
python-dotenv>=1.0.0
asyncio
typing-extensions>=4.0.0

# Ê≤ôÁÆ±ÁâπÂÆö‰æùËµñ
docker>=6.0.0                  # Docker Python SDK
psutil>=5.9.0                  # Á≥ªÁªüËµÑÊ∫êÁõëÊéß
resource                       # ËµÑÊ∫êÈôêÂà∂ÔºàÂÜÖÁΩÆÔºâ
tempfile                       # ‰∏¥Êó∂Êñá‰ª∂ÁÆ°ÁêÜÔºàÂÜÖÁΩÆÔºâ
uuid                           # ‰ºöËØùIDÁîüÊàêÔºàÂÜÖÁΩÆÔºâ

# ÂÆâÂÖ®Áõ∏ÂÖ≥
cryptography>=41.0.0           # Âä†ÂØÜÂíåÂÆâÂÖ®
hashlib                        # ÂìàÂ∏åËÆ°ÁÆóÔºàÂÜÖÁΩÆÔºâ

# ÊµãËØïÊ°ÜÊû∂
pytest>=7.0.0
pytest-asyncio>=0.21.0
pytest-docker>=2.0.0

# ÂºÄÂèëÂ∑•ÂÖ∑
black>=23.0.0                  # ‰ª£Á†ÅÊ†ºÂºèÂåñ
flake8>=6.0.0                  # ‰ª£Á†ÅÊ£ÄÊü•
mypy>=1.0.0                    # Á±ªÂûãÊ£ÄÊü•
```

#### 1.3 ÈÖçÁΩÆÁ≥ªÁªüÊâ©Â±ï

Âü∫‰∫éÈ°πÁõÆ6ÁöÑConfigÁ±ªÔºåÊâ©Â±ïÊ≤ôÁÆ±Áõ∏ÂÖ≥ÈÖçÁΩÆÔºö

```python
# utils/config.py Êâ©Â±ïÈÉ®ÂàÜ
@dataclass
class Config:
    # ... ÁªßÊâøÈ°πÁõÆ6ÁöÑÊâÄÊúâÈÖçÁΩÆ ...
    
    # Ê≤ôÁÆ±Âü∫Á°ÄÈÖçÁΩÆ
    sandbox_type: str = "docker"  # "docker", "process"
    sandbox_timeout: int = 30     # ÈªòËÆ§Ë∂ÖÊó∂Êó∂Èó¥ÔºàÁßíÔºâ
    sandbox_memory_limit: int = 512  # ÂÜÖÂ≠òÈôêÂà∂ÔºàMBÔºâ
    sandbox_cpu_limit: float = 1.0   # CPUÈôêÂà∂
    sandbox_network_access: bool = False  # ÁΩëÁªúËÆøÈóÆ
    sandbox_file_system_access: bool = False  # Êñá‰ª∂Á≥ªÁªüËÆøÈóÆ
    
    # DockerÁâπÂÆöÈÖçÁΩÆ
    docker_host: str = "unix://var/run/docker.sock"
    docker_api_version: str = "auto"
    docker_timeout: int = 60
    docker_auto_remove: bool = True
    docker_pull_policy: str = "missing"  # "always", "missing", "never"
    
    # ÊîØÊåÅÁöÑËØ≠Ë®ÄÈÖçÁΩÆ
    supported_languages: List[str] = field(default_factory=lambda: [
        "python", "javascript", "java", "go", "bash"
    ])
    
    # ËØ≠Ë®ÄÁâπÂÆöÈÖçÁΩÆ
    python_version: str = "3.12"
    node_version: str = "18"
    java_version: str = "11"
    go_version: str = "1.19"
    
    # ÂÆâÂÖ®ÈÖçÁΩÆ
    max_concurrent_executions: int = 5
    max_session_duration: int = 3600  # 1Â∞èÊó∂
    max_file_size: int = 1024 * 1024  # 1MB
    allowed_imports: List[str] = field(default_factory=list)
    blocked_imports: List[str] = field(default_factory=lambda: [
        "os", "subprocess", "socket", "urllib", "requests"
    ])
```

### Èò∂ÊÆµ2ÔºöÊ≤ôÁÆ±Ê†∏ÂøÉÂÆûÁé∞ (Á¨¨3-5Â§©)

#### 2.1 Ê≤ôÁÆ±Âü∫Á±ªÂÆûÁé∞

**sandbox/base.py**:
```python
"""
Ê≤ôÁÆ±Âü∫Á±ªÂíåÊï∞ÊçÆÊ®°Âûã

ÂÆö‰πâÊ≤ôÁÆ±Á≥ªÁªüÁöÑÊ†∏ÂøÉÊäΩË±°ÂíåÊï∞ÊçÆÁªìÊûÑ„ÄÇ
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum
import time
import uuid
from pydantic import BaseModel, Field


class ExecutionStatus(str, Enum):
    """ÊâßË°åÁä∂ÊÄÅÊûö‰∏æ"""
    SUCCESS = "success"
    ERROR = "error"
    TIMEOUT = "timeout"
    MEMORY_LIMIT = "memory_limit"
    CPU_LIMIT = "cpu_limit"
    SECURITY_VIOLATION = "security_violation"


@dataclass
class ExecutionResult:
    """ÊâßË°åÁªìÊûúÊï∞ÊçÆÁ±ª"""
    success: bool
    output: str
    error: str
    execution_time: float
    memory_usage: Optional[int] = None
    exit_code: Optional[int] = None
    session_id: str = ""
    status: ExecutionStatus = ExecutionStatus.SUCCESS
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè"""
        return {
            "success": self.success,
            "output": self.output,
            "error": self.error,
            "execution_time": self.execution_time,
            "memory_usage": self.memory_usage,
            "exit_code": self.exit_code,
            "session_id": self.session_id,
            "status": self.status.value,
            "metadata": self.metadata
        }


@dataclass
class SandboxConfig:
    """Ê≤ôÁÆ±ÈÖçÁΩÆÊï∞ÊçÆÁ±ª"""
    timeout: int = 30
    memory_limit: int = 512  # MB
    cpu_limit: float = 1.0
    network_access: bool = False
    file_system_access: bool = False
    allowed_imports: List[str] = field(default_factory=list)
    blocked_imports: List[str] = field(default_factory=list)
    max_output_size: int = 1024 * 1024  # 1MB
    working_directory: str = "/workspace"
    
    def validate(self) -> None:
        """È™åËØÅÈÖçÁΩÆÂèÇÊï∞"""
        if self.timeout <= 0:
            raise ValueError("timeout must be positive")
        if self.memory_limit <= 0:
            raise ValueError("memory_limit must be positive")
        if self.cpu_limit <= 0:
            raise ValueError("cpu_limit must be positive")


class BaseSandbox(ABC):
    """Ê≤ôÁÆ±ÊäΩË±°Âü∫Á±ª"""
    
    def __init__(self, config: SandboxConfig):
        self.config = config
        self.config.validate()
        self.sessions: Dict[str, Dict[str, Any]] = {}
        self._stats = {
            "total_executions": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "total_execution_time": 0.0
        }
    
    @abstractmethod
    async def execute(self, code: str, language: str = "python", 
                     session_id: Optional[str] = None) -> ExecutionResult:
        """ÊâßË°å‰ª£Á†Å"""
        pass
    
    @abstractmethod
    async def create_session(self) -> str:
        """ÂàõÂª∫Êñ∞‰ºöËØù"""
        pass
    
    @abstractmethod
    async def destroy_session(self, session_id: str) -> bool:
        """ÈîÄÊØÅ‰ºöËØù"""
        pass
    
    @abstractmethod
    async def list_sessions(self) -> List[str]:
        """ÂàóÂá∫ÊâÄÊúâÊ¥ªË∑É‰ºöËØù"""
        pass
    
    @abstractmethod
    async def cleanup(self) -> None:
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        pass
    
    def generate_session_id(self) -> str:
        """ÁîüÊàêÂîØ‰∏Ä‰ºöËØùID"""
        return str(uuid.uuid4())
    
    def update_stats(self, result: ExecutionResult) -> None:
        """Êõ¥Êñ∞ÁªüËÆ°‰ø°ÊÅØ"""
        self._stats["total_executions"] += 1
        if result.success:
            self._stats["successful_executions"] += 1
        else:
            self._stats["failed_executions"] += 1
        self._stats["total_execution_time"] += result.execution_time
    
    def get_stats(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ"""
        return self._stats.copy()
```

#### 2.2 DockerÊ≤ôÁÆ±ÂÆûÁé∞

**sandbox/docker_sandbox.py**:
```python
"""
DockerÊ≤ôÁÆ±ÂÆûÁé∞

‰ΩøÁî®DockerÂÆπÂô®Êèê‰æõÂÆâÂÖ®ÁöÑ‰ª£Á†ÅÊâßË°åÁéØÂ¢É„ÄÇ
"""

import docker
import asyncio
import tempfile
import os
import time
import logging
from typing import Dict, Any, Optional, List
from pathlib import Path

from .base import BaseSandbox, ExecutionResult, SandboxConfig, ExecutionStatus
from ..utils.logger import get_logger

logger = get_logger(__name__)


class DockerSandbox(BaseSandbox):
    """DockerÊ≤ôÁÆ±ÂÆûÁé∞"""
    
    def __init__(self, config: SandboxConfig):
        super().__init__(config)
        self.client = docker.from_env()
        self.language_images = {
            'python': 'python:3.9-slim',
            'javascript': 'node:18-slim',
            'java': 'openjdk:11-slim',
            'go': 'golang:1.19-slim',
            'bash': 'ubuntu:22.04'
        }
        self._ensure_images()
    
    def _ensure_images(self) -> None:
        """Á°Æ‰øùÊâÄÈúÄÈïúÂÉèÂ≠òÂú®"""
        for language, image in self.language_images.items():
            try:
                self.client.images.get(image)
                logger.info(f"ÈïúÂÉè {image} Â∑≤Â≠òÂú®")
            except docker.errors.ImageNotFound:
                logger.info(f"ÊãâÂèñÈïúÂÉè {image}...")
                self.client.images.pull(image)
                logger.info(f"ÈïúÂÉè {image} ÊãâÂèñÂÆåÊàê")
    
    async def execute(self, code: str, language: str = "python", 
                     session_id: Optional[str] = None) -> ExecutionResult:
        """Âú®DockerÂÆπÂô®‰∏≠ÊâßË°å‰ª£Á†Å"""
        start_time = time.time()
        
        try:
            # È™åËØÅËØ≠Ë®ÄÊîØÊåÅ
            if language not in self.language_images:
                return ExecutionResult(
                    success=False,
                    output="",
                    error=f"‰∏çÊîØÊåÅÁöÑËØ≠Ë®Ä: {language}",
                    execution_time=0,
                    status=ExecutionStatus.ERROR
                )
            
            # ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂
            with tempfile.NamedTemporaryFile(
                mode='w', 
                suffix=self._get_file_extension(language), 
                delete=False
            ) as f:
                f.write(code)
                temp_file = f.name
            
            try:
                # ËøêË°åÂÆπÂô®
                result = await self._run_container(
                    self.language_images[language], 
                    temp_file, 
                    language
                )
                
                execution_time = time.time() - start_time
                
                exec_result = ExecutionResult(
                    success=result['exit_code'] == 0,
                    output=result['output'],
                    error=result['error'],
                    execution_time=execution_time,
                    exit_code=result['exit_code'],
                    session_id=session_id or "",
                    status=ExecutionStatus.SUCCESS if result['exit_code'] == 0 else ExecutionStatus.ERROR,
                    metadata={
                        'language': language,
                        'container_id': result.get('container_id', ''),
                        'memory_usage': result.get('memory_usage', 0)
                    }
                )
                
                self.update_stats(exec_result)
                return exec_result
                
            finally:
                # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
                os.unlink(temp_file)
                
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"‰ª£Á†ÅÊâßË°åÂºÇÂ∏∏: {e}")
            
            result = ExecutionResult(
                success=False,
                output="",
                error=str(e),
                execution_time=execution_time,
                status=ExecutionStatus.ERROR
            )
            self.update_stats(result)
            return result
    
    async def _run_container(self, image: str, code_file: str, language: str) -> Dict[str, Any]:
        """ËøêË°åDockerÂÆπÂô®"""
        command = self._get_run_command(language, os.path.basename(code_file))
        
        # ÂÆπÂô®ÈÖçÁΩÆ
        container_config = {
            'image': image,
            'command': command,
            'volumes': {
                os.path.dirname(code_file): {
                    'bind': '/workspace', 
                    'mode': 'ro'
                }
            },
            'working_dir': '/workspace',
            'mem_limit': f'{self.config.memory_limit}m',
            'cpu_period': 100000,
            'cpu_quota': int(100000 * self.config.cpu_limit),
            'network_disabled': not self.config.network_access,
            'remove': True,
            'stdout': True,
            'stderr': True,
            'user': '1000:1000',  # ÈùûrootÁî®Êà∑
            'security_opt': ['no-new-privileges:true'],  # ÂÆâÂÖ®ÈÄâÈ°π
            'cap_drop': ['ALL'],  # ÁßªÈô§ÊâÄÊúâcapabilities
            'read_only': True,  # Âè™ËØªÊñá‰ª∂Á≥ªÁªü
            'tmpfs': {'/tmp': 'noexec,nosuid,size=100m'}  # ‰∏¥Êó∂Êñá‰ª∂Á≥ªÁªü
        }
        
        container = None
        try:
            # ÂàõÂª∫Âπ∂ÂêØÂä®ÂÆπÂô®
            container = self.client.containers.run(**container_config, detach=True)
            
            # Á≠âÂæÖÊâßË°åÂÆåÊàê
            result = container.wait(timeout=self.config.timeout)
            
            # Ëé∑ÂèñËæìÂá∫
            logs = container.logs(stdout=True, stderr=True).decode('utf-8')
            
            # Ëé∑ÂèñÂÆπÂô®ÁªüËÆ°‰ø°ÊÅØ
            stats = container.stats(stream=False)
            memory_usage = stats['memory_stats'].get('usage', 0)
            
            return {
                'exit_code': result['StatusCode'],
                'output': logs if result['StatusCode'] == 0 else '',
                'error': logs if result['StatusCode'] != 0 else '',
                'container_id': container.id,
                'memory_usage': memory_usage
            }
            
        except docker.errors.ContainerError as e:
            return {
                'exit_code': e.exit_status,
                'output': '',
                'error': str(e),
                'container_id': container.id if container else ''
            }
        except Exception as e:
            return {
                'exit_code': -1,
                'output': '',
                'error': str(e),
                'container_id': container.id if container else ''
            }
        finally:
            # Á°Æ‰øùÂÆπÂô®Ë¢´Ê∏ÖÁêÜ
            if container:
                try:
                    container.remove(force=True)
                except:
                    pass
    
    def _get_file_extension(self, language: str) -> str:
        """Ëé∑ÂèñÊñá‰ª∂Êâ©Â±ïÂêç"""
        extensions = {
            'python': '.py',
            'javascript': '.js',
            'java': '.java',
            'go': '.go',
            'bash': '.sh'
        }
        return extensions.get(language, '.txt')
    
    def _get_run_command(self, language: str, filename: str) -> List[str]:
        """Ëé∑ÂèñËøêË°åÂëΩ‰ª§"""
        commands = {
            'python': ['python', filename],
            'javascript': ['node', filename],
            'java': ['sh', '-c', f'javac {filename} && java {filename[:-5]}'],
            'go': ['go', 'run', filename],
            'bash': ['bash', filename]
        }
        return commands.get(language, ['cat', filename])
    
    async def create_session(self) -> str:
        """ÂàõÂª∫Êñ∞‰ºöËØù"""
        session_id = self.generate_session_id()
        self.sessions[session_id] = {
            'created_at': time.time(),
            'last_used': time.time(),
            'executions': 0
        }
        logger.info(f"ÂàõÂª∫‰ºöËØù: {session_id}")
        return session_id
    
    async def destroy_session(self, session_id: str) -> bool:
        """ÈîÄÊØÅ‰ºöËØù"""
        if session_id in self.sessions:
            del self.sessions[session_id]
            logger.info(f"ÈîÄÊØÅ‰ºöËØù: {session_id}")
            return True
        return False
    
    async def list_sessions(self) -> List[str]:
        """ÂàóÂá∫ÊâÄÊúâÊ¥ªË∑É‰ºöËØù"""
        return list(self.sessions.keys())
    
    async def cleanup(self) -> None:
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        # Ê∏ÖÁêÜÊâÄÊúâ‰ºöËØù
        for session_id in list(self.sessions.keys()):
            await self.destroy_session(session_id)
        
        # Ê∏ÖÁêÜDockerËµÑÊ∫ê
        try:
            # Ê∏ÖÁêÜÊÇ¨Á©∫ÂÆπÂô®
            containers = self.client.containers.list(
                all=True, 
                filters={'status': 'exited'}
            )
            for container in containers:
                if 'sandbox' in container.name:
                    container.remove()
            
            logger.info("DockerËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê")
        except Exception as e:
            logger.error(f"DockerËµÑÊ∫êÊ∏ÖÁêÜÂ§±Ë¥•: {e}")
```

### Èò∂ÊÆµ3ÔºöÂ∑•ÂÖ∑Á≥ªÁªüÈõÜÊàê (Á¨¨6-7Â§©)

#### 3.1 ‰ª£Á†ÅÊâßË°åÂ∑•ÂÖ∑

**tools/code_executor.py**:
```python
"""
‰ª£Á†ÅÊâßË°åÂ∑•ÂÖ∑

Â∞ÜÊ≤ôÁÆ±ÂäüËÉΩÂ∞ÅË£Ö‰∏∫Â∑•ÂÖ∑ÔºåÈõÜÊàêÂà∞Â∑•ÂÖ∑ÁÆ°ÁêÜÁ≥ªÁªü‰∏≠„ÄÇ
"""

import asyncio
import logging
from typing import Dict, Any, Optional, Union
from pathlib import Path

# ÁªßÊâøÈ°πÁõÆ6ÁöÑÂü∫Á°ÄÂ∑•ÂÖ∑Á±ª
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', 'practical6'))

from practical6.tools.base import BaseTool, ToolResult, ToolResultStatus
from ..sandbox.docker_sandbox import DockerSandbox
from ..sandbox.base import SandboxConfig
from ..utils.config import get_config
from ..utils.logger import get_logger

logger = get_logger(__name__)


class CodeExecutorTool(BaseTool):
    """‰ª£Á†ÅÊâßË°åÂ∑•ÂÖ∑"""
    
    def __init__(self):
        super().__init__(
            name="code_executor",
            description="ÂÆâÂÖ®ÊâßË°å‰ª£Á†ÅÂπ∂ËøîÂõûÁªìÊûúÔºåÊîØÊåÅÂ§öÁßçÁºñÁ®ãËØ≠Ë®Ä"
        )
        
        config = get_config()
        sandbox_config = SandboxConfig(
            timeout=config.sandbox_timeout,
            memory_limit=config.sandbox_memory_limit,
            cpu_limit=config.sandbox_cpu_limit,
            network_access=config.sandbox_network_access,
            file_system_access=config.sandbox_file_system_access,
            allowed_imports=config.allowed_imports,
            blocked_imports=config.blocked_imports
        )
        
        self.sandbox = DockerSandbox(sandbox_config)
        self._execution_count = 0
    
    @property
    def schema(self) -> Dict[str, Any]:
        """Â∑•ÂÖ∑ÂèÇÊï∞Ê®°Âºè"""
        return {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "Ë¶ÅÊâßË°åÁöÑ‰ª£Á†Å"
                },
                "language": {
                    "type": "string",
                    "description": "ÁºñÁ®ãËØ≠Ë®Ä",
                    "enum": ["python", "javascript", "java", "go", "bash"],
                    "default": "python"
                },
                "session_id": {
                    "type": "string",
                    "description": "‰ºöËØùIDÔºàÂèØÈÄâÔºåÁî®‰∫é‰øùÊåÅÁä∂ÊÄÅÔºâ"
                }
            },
            "required": ["code"]
        }
    
    async def execute(self, **kwargs) -> ToolResult:
        """ÊâßË°å‰ª£Á†Å"""
        try:
            # ÂèÇÊï∞È™åËØÅ
            validation_result = self.validate_input(**kwargs)
            if validation_result is not True:
                return ToolResult.invalid_input(validation_result)
            
            code = kwargs.get("code", "")
            language = kwargs.get("language", "python")
            session_id = kwargs.get("session_id")
            
            # ‰ª£Á†ÅÂÆâÂÖ®Ê£ÄÊü•
            if not self._is_code_safe(code, language):
                return ToolResult.error(
                    "‰ª£Á†ÅÂåÖÂê´‰∏çÂÆâÂÖ®ÁöÑÊìç‰Ωú",
                    metadata={"security_check": "failed"}
                )
            
            # ÊâßË°å‰ª£Á†Å
            logger.info(f"ÊâßË°å{language}‰ª£Á†ÅÔºå‰ºöËØùID: {session_id}")
            result = await self.sandbox.execute(code, language, session_id)
            
            self._execution_count += 1
            
            if result.success:
                return ToolResult.success(
                    content={
                        "output": result.output,
                        "execution_time": result.execution_time,
                        "language": language,
                        "session_id": result.session_id
                    },
                    execution_time=result.execution_time,
                    metadata={
                        "exit_code": result.exit_code,
                        "memory_usage": result.memory_usage,
                        "execution_count": self._execution_count
                    }
                )
            else:
                return ToolResult.error(
                    result.error,
                    execution_time=result.execution_time,
                    metadata={
                        "exit_code": result.exit_code,
                        "status": result.status.value
                    }
                )
                
        except Exception as e:
            logger.error(f"‰ª£Á†ÅÊâßË°åÂ∑•ÂÖ∑ÂºÇÂ∏∏: {e}")
            return ToolResult.error(f"ÊâßË°åÂºÇÂ∏∏: {str(e)}")
    
    def validate_input(self, **kwargs) -> Union[bool, str]:
        """È™åËØÅËæìÂÖ•ÂèÇÊï∞"""
        code = kwargs.get("code")
        if not code or not isinstance(code, str):
            return "‰ª£Á†Å‰∏çËÉΩ‰∏∫Á©∫‰∏îÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤"
        
        if len(code) > 10000:  # 10KBÈôêÂà∂
            return "‰ª£Á†ÅÈïøÂ∫¶‰∏çËÉΩË∂ÖËøá10KB"
        
        language = kwargs.get("language", "python")
        supported_languages = ["python", "javascript", "java", "go", "bash"]
        if language not in supported_languages:
            return f"‰∏çÊîØÊåÅÁöÑËØ≠Ë®Ä: {language}ÔºåÊîØÊåÅÁöÑËØ≠Ë®Ä: {supported_languages}"
        
        return True
    
    def _is_code_safe(self, code: str, language: str) -> bool:
        """Âü∫Á°Ä‰ª£Á†ÅÂÆâÂÖ®Ê£ÄÊü•"""
        # Âç±Èô©ÂÖ≥ÈîÆËØçÊ£ÄÊü•
        dangerous_keywords = {
            'python': [
                'import os', 'import subprocess', 'import socket',
                'import urllib', 'import requests', '__import__',
                'eval(', 'exec(', 'compile(', 'open('
            ],
            'javascript': [
                'require(', 'import(', 'fetch(', 'XMLHttpRequest',
                'process.', 'child_process', 'fs.', 'net.'
            ],
            'java': [
                'Runtime.', 'ProcessBuilder', 'System.exit',
                'File(', 'FileInputStream', 'Socket('
            ],
            'bash': [
                'rm -rf', 'sudo', 'su -', 'chmod +x',
                'wget', 'curl', 'nc ', 'netcat'
            ]
        }
        
        if language in dangerous_keywords:
            for keyword in dangerous_keywords[language]:
                if keyword in code:
                    logger.warning(f"Ê£ÄÊµãÂà∞Âç±Èô©ÂÖ≥ÈîÆËØç: {keyword}")
                    return False
        
        return True
    
    async def cleanup(self) -> None:
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        if hasattr(self, 'sandbox'):
            await self.sandbox.cleanup()
```

#### 3.2 ‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑

**tools/session_manager.py**:
```python
"""
‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑

ÁÆ°ÁêÜ‰ª£Á†ÅÊâßË°å‰ºöËØùÁöÑÁîüÂëΩÂë®Êúü„ÄÇ
"""

import asyncio
import time
from typing import Dict, Any, List, Optional, Union

from practical6.tools.base import BaseTool, ToolResult, ToolResultStatus
from ..sandbox.docker_sandbox import DockerSandbox
from ..utils.logger import get_logger

logger = get_logger(__name__)


class SessionManagerTool(BaseTool):
    """‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑"""
    
    def __init__(self, sandbox: DockerSandbox):
        super().__init__(
            name="session_manager",
            description="ÁÆ°ÁêÜ‰ª£Á†ÅÊâßË°å‰ºöËØùÔºåÂåÖÊã¨ÂàõÂª∫„ÄÅÈîÄÊØÅÂíåÊü•ËØ¢‰ºöËØù"
        )
        self.sandbox = sandbox
    
    @property
    def schema(self) -> Dict[str, Any]:
        """Â∑•ÂÖ∑ÂèÇÊï∞Ê®°Âºè"""
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Êìç‰ΩúÁ±ªÂûã",
                    "enum": ["create", "destroy", "list", "info"]
                },
                "session_id": {
                    "type": "string",
                    "description": "‰ºöËØùIDÔºàdestroyÂíåinfoÊìç‰ΩúÈúÄË¶ÅÔºâ"
                }
            },
            "required": ["action"]
        }
    
    async def execute(self, **kwargs) -> ToolResult:
        """ÊâßË°å‰ºöËØùÁÆ°ÁêÜÊìç‰Ωú"""
        try:
            validation_result = self.validate_input(**kwargs)
            if validation_result is not True:
                return ToolResult.invalid_input(validation_result)
            
            action = kwargs.get("action")
            session_id = kwargs.get("session_id")
            
            if action == "create":
                return await self._create_session()
            elif action == "destroy":
                return await self._destroy_session(session_id)
            elif action == "list":
                return await self._list_sessions()
            elif action == "info":
                return await self._get_session_info(session_id)
            else:
                return ToolResult.error(f"Êú™Áü•Êìç‰Ωú: {action}")
                
        except Exception as e:
            logger.error(f"‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑ÂºÇÂ∏∏: {e}")
            return ToolResult.error(f"Êìç‰ΩúÂºÇÂ∏∏: {str(e)}")
    
    async def _create_session(self) -> ToolResult:
        """ÂàõÂª∫Êñ∞‰ºöËØù"""
        session_id = await self.sandbox.create_session()
        return ToolResult.success({
            "session_id": session_id,
            "message": "‰ºöËØùÂàõÂª∫ÊàêÂäü"
        })
    
    async def _destroy_session(self, session_id: str) -> ToolResult:
        """ÈîÄÊØÅ‰ºöËØù"""
        if not session_id:
            return ToolResult.invalid_input("session_id‰∏çËÉΩ‰∏∫Á©∫")
        
        success = await self.sandbox.destroy_session(session_id)
        if success:
            return ToolResult.success({
                "session_id": session_id,
                "message": "‰ºöËØùÈîÄÊØÅÊàêÂäü"
            })
        else:
            return ToolResult.error(f"‰ºöËØù‰∏çÂ≠òÂú®: {session_id}")
    
    async def _list_sessions(self) -> ToolResult:
        """ÂàóÂá∫ÊâÄÊúâ‰ºöËØù"""
        sessions = await self.sandbox.list_sessions()
        return ToolResult.success({
            "sessions": sessions,
            "count": len(sessions)
        })
    
    async def _get_session_info(self, session_id: str) -> ToolResult:
        """Ëé∑Âèñ‰ºöËØù‰ø°ÊÅØ"""
        if not session_id:
            return ToolResult.invalid_input("session_id‰∏çËÉΩ‰∏∫Á©∫")
        
        if session_id in self.sandbox.sessions:
            session_info = self.sandbox.sessions[session_id].copy()
            session_info["session_id"] = session_id
            session_info["age"] = time.time() - session_info["created_at"]
            return ToolResult.success(session_info)
        else:
            return ToolResult.error(f"‰ºöËØù‰∏çÂ≠òÂú®: {session_id}")
    
    def validate_input(self, **kwargs) -> Union[bool, str]:
        """È™åËØÅËæìÂÖ•ÂèÇÊï∞"""
        action = kwargs.get("action")
        if not action:
            return "actionÂèÇÊï∞‰∏çËÉΩ‰∏∫Á©∫"
        
        valid_actions = ["create", "destroy", "list", "info"]
        if action not in valid_actions:
            return f"Êó†ÊïàÁöÑaction: {action}ÔºåÊúâÊïàÂÄº: {valid_actions}"
        
        if action in ["destroy", "info"]:
            session_id = kwargs.get("session_id")
            if not session_id:
                return f"{action}Êìç‰ΩúÈúÄË¶Åsession_idÂèÇÊï∞"
        
        return True
```

### Èò∂ÊÆµ4Ôºö‰ª£ÁêÜÈõÜÊàê (Á¨¨8-9Â§©)

#### 4.1 Ê≤ôÁÆ±‰ª£ÁêÜÂÆûÁé∞

**agent/sandbox_agent.py**:
```python
"""
Ê≤ôÁÆ±‰ª£ÁêÜ

ÈõÜÊàêÊ≤ôÁÆ±ÊâßË°åÁéØÂ¢ÉÁöÑÊô∫ËÉΩ‰ª£ÁêÜÔºåÊîØÊåÅÁºñÁ®ãÈóÆÈ¢òËß£ÂÜ≥„ÄÇ
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional, Union
from dataclasses import dataclass

# ÁªßÊâøÈ°πÁõÆ6ÁöÑÂ§öÊ®°ÊÄÅ‰ª£ÁêÜ
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', 'practical6'))

from practical6.agent.multimodal_agent import MultimodalAgent
from practical6.tools.manager import ToolManager
from practical6.utils.config import Config as BaseConfig

from ..sandbox.docker_sandbox import DockerSandbox
from ..sandbox.base import SandboxConfig
from ..tools.code_executor import CodeExecutorTool
from ..tools.session_manager import SessionManagerTool
from ..utils.config import get_config
from ..utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class CodingTask:
    """ÁºñÁ®ã‰ªªÂä°Êï∞ÊçÆÁ±ª"""
    description: str
    language: str = "python"
    requirements: List[str] = None
    test_cases: List[Dict[str, Any]] = None
    session_id: Optional[str] = None


class SandboxAgent(MultimodalAgent):
    """Ê≤ôÁÆ±‰ª£ÁêÜ"""
    
    def __init__(self, config: BaseConfig, max_steps: int = 20):
        super().__init__(config, max_steps)
        
        # ÂàùÂßãÂåñÊ≤ôÁÆ±
        sandbox_config = SandboxConfig(
            timeout=getattr(config, 'sandbox_timeout', 30),
            memory_limit=getattr(config, 'sandbox_memory_limit', 512),
            cpu_limit=getattr(config, 'sandbox_cpu_limit', 1.0),
            network_access=getattr(config, 'sandbox_network_access', False),
            file_system_access=getattr(config, 'sandbox_file_system_access', False)
        )
        
        self.sandbox = DockerSandbox(sandbox_config)
        
        # Ê≥®ÂÜåÊ≤ôÁÆ±Â∑•ÂÖ∑
        self._register_sandbox_tools()
        
        # ÁºñÁ®ã‰ªªÂä°ÂéÜÂè≤
        self.coding_history: List[CodingTask] = []
    
    def _register_sandbox_tools(self) -> None:
        """Ê≥®ÂÜåÊ≤ôÁÆ±Áõ∏ÂÖ≥Â∑•ÂÖ∑"""
        # ‰ª£Á†ÅÊâßË°åÂ∑•ÂÖ∑
        code_executor = CodeExecutorTool()
        self.tool_manager.register_tool(code_executor)
        
        # ‰ºöËØùÁÆ°ÁêÜÂ∑•ÂÖ∑
        session_manager = SessionManagerTool(self.sandbox)
        self.tool_manager.register_tool(session_manager)
        
        logger.info("Ê≤ôÁÆ±Â∑•ÂÖ∑Ê≥®ÂÜåÂÆåÊàê")
    
    async def solve_coding_problem(self, problem_description: str, 
                                 language: str = "python",
                                 requirements: List[str] = None,
                                 test_cases: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Ëß£ÂÜ≥ÁºñÁ®ãÈóÆÈ¢ò"""
        
        # ÂàõÂª∫ÁºñÁ®ã‰ªªÂä°
        task = CodingTask(
            description=problem_description,
            language=language,
            requirements=requirements or [],
            test_cases=test_cases or []
        )
        
        # ÊûÑÂª∫Â¢ûÂº∫ÊèêÁ§∫
        enhanced_prompt = self._build_coding_prompt(task)
        
        # ÂàõÂª∫‰ºöËØù
        session_result = await self.tool_manager.execute_tool("session_manager", action="create")
        if session_result.is_success:
            task.session_id = session_result.content["session_id"]
            logger.info(f"‰∏∫ÁºñÁ®ã‰ªªÂä°ÂàõÂª∫‰ºöËØù: {task.session_id}")
        
        try:
            # ÊâßË°åÊé®ÁêÜ
            result = await self.solve_multimodal(enhanced_prompt, task_type="coding")
            
            # ËÆ∞ÂΩï‰ªªÂä°ÂéÜÂè≤
            self.coding_history.append(task)
            
            # Â¢ûÂº∫ÁªìÊûú‰ø°ÊÅØ
            result["task_info"] = {
                "language": task.language,
                "session_id": task.session_id,
                "requirements": task.requirements,
                "test_cases_count": len(task.test_cases)
            }
            
            return result
            
        finally:
            # Ê∏ÖÁêÜ‰ºöËØùÔºàÂèØÈÄâÔºâ
            if task.session_id:
                await self.tool_manager.execute_tool(
                    "session_manager", 
                    action="destroy", 
                    session_id=task.session_id
                )
    
    def _build_coding_prompt(self, task: CodingTask) -> str:
        """ÊûÑÂª∫ÁºñÁ®ã‰ªªÂä°ÊèêÁ§∫"""
        prompt_parts = [
            f"‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑ{task.language}ÁºñÁ®ãÂä©ÊâãÔºåÈúÄË¶ÅËß£ÂÜ≥‰ª•‰∏ãÁºñÁ®ãÈóÆÈ¢òÔºö",
            f"\nÈóÆÈ¢òÊèèËø∞Ôºö{task.description}",
            f"\nÁºñÁ®ãËØ≠Ë®ÄÔºö{task.language}"
        ]
        
        if task.requirements:
            prompt_parts.append(f"\nË¶ÅÊ±ÇÔºö")
            for i, req in enumerate(task.requirements, 1):
                prompt_parts.append(f"{i}. {req}")
        
        if task.test_cases:
            prompt_parts.append(f"\nÊµãËØïÁî®‰æãÔºö")
            for i, test_case in enumerate(task.test_cases, 1):
                input_data = test_case.get("input", "")
                expected_output = test_case.get("output", "")
                prompt_parts.append(f"ÊµãËØï{i}: ËæìÂÖ•={input_data}, ÊúüÊúõËæìÂá∫={expected_output}")
        
        prompt_parts.extend([
            f"\nÂèØÁî®Â∑•ÂÖ∑Ôºö",
            f"1. code_executor - ÊâßË°å{task.language}‰ª£Á†ÅÂπ∂Ëé∑ÂèñÁªìÊûú",
            f"2. session_manager - ÁÆ°ÁêÜ‰ª£Á†ÅÊâßË°å‰ºöËØù",
            f"\nËØ∑Êåâ‰ª•‰∏ãÊ≠•È™§Ëß£ÂÜ≥ÈóÆÈ¢òÔºö",
            f"1. ÂàÜÊûêÈóÆÈ¢òÈúÄÊ±Ç",
            f"2. ËÆæËÆ°Ëß£ÂÜ≥ÊñπÊ°à",
            f"3. ÁºñÂÜô‰ª£Á†ÅÂÆûÁé∞",
            f"4. ÊâßË°å‰ª£Á†ÅÈ™åËØÅ",
            f"5. Ê†πÊçÆÁªìÊûú‰ºòÂåñ‰ª£Á†Å",
            f"6. Êèê‰æõÊúÄÁªàËß£ÂÜ≥ÊñπÊ°à",
            f"\nÊ≥®ÊÑèÔºöËØ∑Á°Æ‰øù‰ª£Á†ÅÁöÑÊ≠£Á°ÆÊÄß„ÄÅÊïàÁéáÂíåÂèØËØªÊÄß„ÄÇ"
        ])
        
        return "\n".join(prompt_parts)
    
    async def execute_code_with_tests(self, code: str, language: str = "python",
                                    test_cases: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """ÊâßË°å‰ª£Á†ÅÂπ∂ËøêË°åÊµãËØïÁî®‰æã"""
        results = {
            "code_execution": None,
            "test_results": [],
            "all_tests_passed": True
        }
        
        # ÊâßË°å‰∏ª‰ª£Á†Å
        exec_result = await self.tool_manager.execute_tool(
            "code_executor",
            code=code,
            language=language
        )
        results["code_execution"] = exec_result.to_dict()
        
        # ËøêË°åÊµãËØïÁî®‰æã
        if test_cases and exec_result.is_success:
            for i, test_case in enumerate(test_cases):
                test_code = self._generate_test_code(code, test_case, language)
                test_result = await self.tool_manager.execute_tool(
                    "code_executor",
                    code=test_code,
                    language=language
                )
                
                test_passed = self._evaluate_test_result(
                    test_result, 
                    test_case.get("output", "")
                )
                
                results["test_results"].append({
                    "test_case": i + 1,
                    "input": test_case.get("input", ""),
                    "expected": test_case.get("output", ""),
                    "actual": test_result.content.get("output", "") if test_result.is_success else "ERROR",
                    "passed": test_passed,
                    "execution_result": test_result.to_dict()
                })
                
                if not test_passed:
                    results["all_tests_passed"] = False
        
        return results
    
    def _generate_test_code(self, original_code: str, test_case: Dict[str, Any], 
                          language: str) -> str:
        """ÁîüÊàêÊµãËØï‰ª£Á†Å"""
        if language == "python":
            return f"""
{original_code}

# ÊµãËØïÁî®‰æã
test_input = {repr(test_case.get("input", ""))}
try:
    result = main(test_input) if 'main' in globals() else eval(test_input)
    print(result)
except Exception as e:
    print(f"ERROR: {{e}}")
"""
        elif language == "javascript":
            return f"""
{original_code}

// ÊµãËØïÁî®‰æã
const testInput = {test_case.get("input", "")};
try {{
    const result = typeof main === 'function' ? main(testInput) : eval(testInput);
    console.log(result);
}} catch (e) {{
    console.log(`ERROR: ${{e}}`);
}}
"""
        else:
            return original_code
    
    def _evaluate_test_result(self, test_result, expected_output: str) -> bool:
        """ËØÑ‰º∞ÊµãËØïÁªìÊûú"""
        if not test_result.is_success:
            return False
        
        actual_output = test_result.content.get("output", "").strip()
        expected_output = str(expected_output).strip()
        
        return actual_output == expected_output
    
    async def get_sandbox_stats(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÊ≤ôÁÆ±ÁªüËÆ°‰ø°ÊÅØ"""
        stats = self.sandbox.get_stats()
        sessions = await self.sandbox.list_sessions()
        
        return {
            "execution_stats": stats,
            "active_sessions": len(sessions),
            "coding_tasks_completed": len(self.coding_history),
            "supported_languages": list(self.sandbox.language_images.keys())
        }
    
    async def cleanup(self) -> None:
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        await super().cleanup()
        if hasattr(self, 'sandbox'):
            await self.sandbox.cleanup()
        logger.info("Ê≤ôÁÆ±‰ª£ÁêÜËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê")


# ‰ΩøÁî®Á§∫‰æã
async def main():
    """ÊºîÁ§∫Ê≤ôÁÆ±‰ª£ÁêÜÁöÑ‰ΩøÁî®"""
    config = get_config()
    agent = SandboxAgent(config)
    
    # Á§∫‰æãÁºñÁ®ãÈóÆÈ¢ò
    problems = [
        {
            "description": "ÁºñÂÜô‰∏Ä‰∏™ÂáΩÊï∞ËÆ°ÁÆóÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÁöÑÁ¨¨nÈ°π",
            "language": "python",
            "requirements": [
                "‰ΩøÁî®ÈÄíÂΩíÂÆûÁé∞",
                "Â§ÑÁêÜËæπÁïåÊÉÖÂÜµÔºàn <= 0Ôºâ",
                "ËøîÂõûÊï¥Êï∞ÁªìÊûú"
            ],
            "test_cases": [
                {"input": "0", "output": "0"},
                {"input": "1", "output": "1"},
                {"input": "5", "output": "5"},
                {"input": "10", "output": "55"}
            ]
        },
        {
            "description": "ÂÆûÁé∞‰∏Ä‰∏™ÁÆÄÂçïÁöÑËÆ°ÁÆóÂô®ÔºåÊîØÊåÅÂä†Âáè‰πòÈô§",
            "language": "javascript",
            "requirements": [
                "ÊîØÊåÅÂü∫Êú¨ÂõõÂàôËøêÁÆó",
                "Â§ÑÁêÜÈô§Èõ∂ÈîôËØØ",
                "ËøîÂõûÊï∞ÂÄºÁªìÊûú"
            ],
            "test_cases": [
                {"input": "2 + 3", "output": "5"},
                {"input": "10 - 4", "output": "6"},
                {"input": "3 * 7", "output": "21"},
                {"input": "15 / 3", "output": "5"}
            ]
        }
    ]
    
    for i, problem in enumerate(problems, 1):
        print(f"\n{'='*60}")
        print(f"ÁºñÁ®ãÈóÆÈ¢ò {i}: {problem['description']}")
        print(f"ËØ≠Ë®Ä: {problem['language']}")
        print('='*60)
        
        try:
            result = await agent.solve_coding_problem(
                problem["description"],
                problem["language"],
                problem["requirements"],
                problem["test_cases"]
            )
            
            print(f"Ëß£ÂÜ≥ÊñπÊ°à: {result.get('final_answer', 'Êú™ÊâæÂà∞Ëß£ÂÜ≥ÊñπÊ°à')}")
            print(f"ÊâßË°åÊ≠•È™§: {len(result.get('steps', []))}")
            print(f"ÊÄªËÄóÊó∂: {result.get('total_time', 0):.2f}Áßí")
            
        except Exception as e:
            print(f"ÊâßË°åÂ§±Ë¥•: {e}")
    
    # ÊòæÁ§∫ÁªüËÆ°‰ø°ÊÅØ
    stats = await agent.get_sandbox_stats()
    print(f"\n{'='*60}")
    print("Ê≤ôÁÆ±ÁªüËÆ°‰ø°ÊÅØ:")
    print(f"ÊÄªÊâßË°åÊ¨°Êï∞: {stats['execution_stats']['total_executions']}")
    print(f"ÊàêÂäüÊâßË°å: {stats['execution_stats']['successful_executions']}")
    print(f"Ê¥ªË∑É‰ºöËØù: {stats['active_sessions']}")
    print(f"ÂÆåÊàê‰ªªÂä°: {stats['coding_tasks_completed']}")
    print('='*60)
    
    # Ê∏ÖÁêÜËµÑÊ∫ê
    await agent.cleanup()


if __name__ == "__main__":
    asyncio.run(main())
```

### Èò∂ÊÆµ5ÔºöÊµãËØïÂíåÊñáÊ°£ (Á¨¨10Â§©)

#### 5.1 ÊµãËØïÊ°ÜÊû∂

**tests/test_sandbox.py**:
```python
"""
Ê≤ôÁÆ±ÊµãËØï

ÊµãËØïÊ≤ôÁÆ±ÁöÑÂü∫Êú¨ÂäüËÉΩÂíåÂÆâÂÖ®ÊÄß„ÄÇ
"""

import pytest
import asyncio
from ..sandbox.docker_sandbox import DockerSandbox
from ..sandbox.base import SandboxConfig, ExecutionStatus


@pytest.fixture
async def sandbox():
    """Ê≤ôÁÆ±ÊµãËØïÂ§πÂÖ∑"""
    config = SandboxConfig(
        timeout=10,
        memory_limit=128,
        cpu_limit=0.5,
        network_access=False
    )
    sandbox = DockerSandbox(config)
    yield sandbox
    await sandbox.cleanup()


@pytest.mark.asyncio
async def test_python_execution(sandbox):
    """ÊµãËØïPython‰ª£Á†ÅÊâßË°å"""
    code = "print('Hello, World!')"
    result = await sandbox.execute(code, "python")
    
    assert result.success
    assert "Hello, World!" in result.output
    assert result.execution_time > 0


@pytest.mark.asyncio
async def test_javascript_execution(sandbox):
    """ÊµãËØïJavaScript‰ª£Á†ÅÊâßË°å"""
    code = "console.log('Hello, JavaScript!');"
    result = await sandbox.execute(code, "javascript")
    
    assert result.success
    assert "Hello, JavaScript!" in result.output


@pytest.mark.asyncio
async def test_timeout_handling(sandbox):
    """ÊµãËØïË∂ÖÊó∂Â§ÑÁêÜ"""
    code = """
import time
time.sleep(15)  # Ë∂ÖËøá10ÁßíË∂ÖÊó∂ÈôêÂà∂
print('This should not print')
"""
    result = await sandbox.execute(code, "python")
    
    assert not result.success
    assert result.status == ExecutionStatus.TIMEOUT


@pytest.mark.asyncio
async def test_memory_limit(sandbox):
    """ÊµãËØïÂÜÖÂ≠òÈôêÂà∂"""
    code = """
# Â∞ùËØïÂàÜÈÖçÂ§ßÈáèÂÜÖÂ≠ò
data = []
for i in range(1000000):
    data.append([0] * 1000)
"""
    result = await sandbox.execute(code, "python")
    
    # Â∫îËØ•Âõ†ÂÜÖÂ≠òÈôêÂà∂ËÄåÂ§±Ë¥•
    assert not result.success


@pytest.mark.asyncio
async def test_session_management(sandbox):
    """ÊµãËØï‰ºöËØùÁÆ°ÁêÜ"""
    # ÂàõÂª∫‰ºöËØù
    session_id = await sandbox.create_session()
    assert session_id
    
    # ÂàóÂá∫‰ºöËØù
    sessions = await sandbox.list_sessions()
    assert session_id in sessions
    
    # ÈîÄÊØÅ‰ºöËØù
    success = await sandbox.destroy_session(session_id)
    assert success
    
    # È™åËØÅ‰ºöËØùÂ∑≤ÈîÄÊØÅ
    sessions = await sandbox.list_sessions()
    assert session_id not in sessions


@pytest.mark.asyncio
async def test_security_isolation(sandbox):
    """ÊµãËØïÂÆâÂÖ®ÈöîÁ¶ª"""
    # Â∞ùËØïËÆøÈóÆÊñá‰ª∂Á≥ªÁªü
    code = """
import os
try:
    os.listdir('/')
    print('File system access succeeded')
except:
    print('File system access denied')
"""
    result = await sandbox.execute(code, "python")
    
    # Â∫îËØ•Ë¢´ÂÆâÂÖ®ÈôêÂà∂ÈòªÊ≠¢
    assert "access denied" in result.output.lower() or not result.success
```

#### 5.2 ÊºîÁ§∫Á®ãÂ∫è

**demo.py**:
```python
"""
Ê≤ôÁÆ±‰ª£ÁêÜÊºîÁ§∫Á®ãÂ∫è

Â±ïÁ§∫Ê≤ôÁÆ±‰ª£ÁêÜÁöÑÂêÑÁßçÂäüËÉΩ„ÄÇ
"""

import asyncio
import logging
from utils.config import get_config
from utils.logger import setup_logger
from agent.sandbox_agent import SandboxAgent


async def demo_basic_execution():
    """ÊºîÁ§∫Âü∫Êú¨‰ª£Á†ÅÊâßË°å"""
    print("\n" + "="*60)
    print("ÊºîÁ§∫1: Âü∫Êú¨‰ª£Á†ÅÊâßË°å")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    # Python‰ª£Á†ÅÊâßË°å
    python_code = """
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

for i in range(10):
    print(f"fib({i}) = {fibonacci(i)}")
"""
    
    result = await agent.tool_manager.execute_tool(
        "code_executor",
        code=python_code,
        language="python"
    )
    
    print("PythonÊâßË°åÁªìÊûú:")
    print(f"ÊàêÂäü: {result.is_success}")
    print(f"ËæìÂá∫: {result.content.get('output', '') if result.is_success else result.error_message}")
    print(f"ÊâßË°åÊó∂Èó¥: {result.execution_time:.2f}Áßí")
    
    await agent.cleanup()


async def demo_coding_problem_solving():
    """ÊºîÁ§∫ÁºñÁ®ãÈóÆÈ¢òËß£ÂÜ≥"""
    print("\n" + "="*60)
    print("ÊºîÁ§∫2: ÁºñÁ®ãÈóÆÈ¢òËß£ÂÜ≥")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    problem = {
        "description": "ÁºñÂÜô‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂà§Êñ≠‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊòØÂê¶‰∏∫ÂõûÊñá",
        "language": "python",
        "requirements": [
            "ÂøΩÁï•Â§ßÂ∞èÂÜô",
            "ÂøΩÁï•Á©∫Ê†ºÂíåÊ†áÁÇπÁ¨¶Âè∑",
            "ËøîÂõûÂ∏ÉÂ∞îÂÄº"
        ],
        "test_cases": [
            {"input": "'racecar'", "output": "True"},
            {"input": "'A man a plan a canal Panama'", "output": "True"},
            {"input": "'hello'", "output": "False"}
        ]
    }
    
    result = await agent.solve_coding_problem(
        problem["description"],
        problem["language"],
        problem["requirements"],
        problem["test_cases"]
    )
    
    print(f"ÈóÆÈ¢ò: {problem['description']}")
    print(f"Ëß£ÂÜ≥ÊñπÊ°à: {result.get('final_answer', 'Êú™ÊâæÂà∞Ëß£ÂÜ≥ÊñπÊ°à')}")
    print(f"ÊâßË°åÊ≠•È™§: {len(result.get('steps', []))}")
    print(f"ÊÄªËÄóÊó∂: {result.get('total_time', 0):.2f}Áßí")
    
    await agent.cleanup()


async def demo_multi_language_support():
    """ÊºîÁ§∫Â§öËØ≠Ë®ÄÊîØÊåÅ"""
    print("\n" + "="*60)
    print("ÊºîÁ§∫3: Â§öËØ≠Ë®ÄÊîØÊåÅ")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    # ‰∏çÂêåËØ≠Ë®ÄÁöÑHello World
    examples = [
        {
            "language": "python",
            "code": "print('Hello from Python!')"
        },
        {
            "language": "javascript",
            "code": "console.log('Hello from JavaScript!');"
        },
        {
            "language": "bash",
            "code": "echo 'Hello from Bash!'"
        }
    ]
    
    for example in examples:
        print(f"\n{example['language'].upper()}:")
        result = await agent.tool_manager.execute_tool(
            "code_executor",
            code=example["code"],
            language=example["language"]
        )
        
        if result.is_success:
            print(f"ËæìÂá∫: {result.content.get('output', '')}")
        else:
            print(f"ÈîôËØØ: {result.error_message}")
    
    await agent.cleanup()


async def demo_session_management():
    """ÊºîÁ§∫‰ºöËØùÁÆ°ÁêÜ"""
    print("\n" + "="*60)
    print("ÊºîÁ§∫4: ‰ºöËØùÁÆ°ÁêÜ")
    print("="*60)
    
    config = get_config()
    agent = SandboxAgent(config)
    
    # ÂàõÂª∫‰ºöËØù
    session_result = await agent.tool_manager.execute_tool(
        "session_manager",
        action="create"
    )
    
    if session_result.is_success:
        session_id = session_result.content["session_id"]
        print(f"ÂàõÂª∫‰ºöËØù: {session_id}")
        
        # Âú®‰ºöËØù‰∏≠ÊâßË°å‰ª£Á†Å
        code1 = "x = 42\nprint(f'x = {x}')"
        result1 = await agent.tool_manager.execute_tool(
            "code_executor",
            code=code1,
            language="python",
            session_id=session_id
        )
        print(f"Á¨¨‰∏ÄÊ¨°ÊâßË°å: {result1.content.get('output', '') if result1.is_success else result1.error_message}")
        
        # Âú®Âêå‰∏Ä‰ºöËØù‰∏≠‰ΩøÁî®‰πãÂâçÁöÑÂèòÈáè
        code2 = "y = x * 2\nprint(f'y = {y}')"
        result2 = await agent.tool_manager.execute_tool(
            "code_executor",
            code=code2,
            language="python",
            session_id=session_id
        )
        print(f"Á¨¨‰∫åÊ¨°ÊâßË°å: {result2.content.get('output', '') if result2.is_success else result2.error_message}")
        
        # ÈîÄÊØÅ‰ºöËØù
        destroy_result = await agent.tool_manager.execute_tool(
            "session_manager",
            action="destroy",
            session_id=session_id
        )
        print(f"ÈîÄÊØÅ‰ºöËØù: {destroy_result.is_success}")
    
    await agent.cleanup()


async def main():
    """‰∏ªÊºîÁ§∫ÂáΩÊï∞"""
    # ËÆæÁΩÆÊó•Âøó
    setup_logger()
    
    print("Ê≤ôÁÆ±‰ª£ÁêÜÊºîÁ§∫Á®ãÂ∫è")
    print("="*60)
    
    try:
        await demo_basic_execution()
        await demo_coding_problem_solving()
        await demo_multi_language_support()
        await demo_session_management()
        
        print("\n" + "="*60)
        print("ÊâÄÊúâÊºîÁ§∫ÂÆåÊàêÔºÅ")
        print("="*60)
        
    except Exception as e:
        logging.error(f"ÊºîÁ§∫ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {e}")
        print(f"ÈîôËØØ: {e}")


if __name__ == "__main__":
    asyncio.run(main())
```

## Â≠¶‰π†Ë¶ÅÁÇπÊÄªÁªì

### üîß ÊäÄÊúØË¶ÅÁÇπ

1. **DockerÂÆπÂô®ÊäÄÊúØ**
   - ÂÆπÂô®ÂàõÂª∫ÂíåÁÆ°ÁêÜ
   - ËµÑÊ∫êÈôêÂà∂ÈÖçÁΩÆ
   - ÂÆâÂÖ®ÈöîÁ¶ªÊú∫Âà∂
   - ÈïúÂÉèÁÆ°ÁêÜÂíå‰ºòÂåñ

2. **ÂºÇÊ≠•ÁºñÁ®ãÊ®°Âºè**
   - async/awaitËØ≠Ê≥ï
   - Âπ∂ÂèëÊâßË°åÊéßÂà∂
   - ËµÑÊ∫êÁÆ°ÁêÜÂíåÊ∏ÖÁêÜ
   - ÂºÇÂ∏∏Â§ÑÁêÜÊú∫Âà∂

3. **ÂÆâÂÖ®ÁºñÁ®ãÂÆûË∑µ**
   - ËæìÂÖ•È™åËØÅÂíåËøáÊª§
   - ÊùÉÈôêÊéßÂà∂ÂíåÈöîÁ¶ª
   - ËµÑÊ∫êÈôêÂà∂ÂíåÁõëÊéß
   - ÂÆâÂÖ®ÂÆ°ËÆ°ÂíåÊó•Âøó

4. **Êû∂ÊûÑËÆæËÆ°Ê®°Âºè**
   - ÊäΩË±°Âü∫Á±ªËÆæËÆ°
   - Á≠ñÁï•Ê®°ÂºèÂ∫îÁî®
   - Â∑•ÂéÇÊ®°ÂºèÂÆûÁé∞
   - ‰æùËµñÊ≥®ÂÖ•ÂéüÁêÜ

### üéØ ‰∏éOpenManusÁöÑÂØπÂ∫îÂÖ≥Á≥ª

1. **‰ª£Á†ÅÊâßË°åÁéØÂ¢É**: ÂØπÂ∫îOpenManusÁöÑÂÆâÂÖ®‰ª£Á†ÅÊâßË°åÂäüËÉΩ
2. **Â§öËØ≠Ë®ÄÊîØÊåÅ**: ÂØπÂ∫îOpenManusÁöÑÂ§öËØ≠Ë®Ä‰ª£ÁêÜËÉΩÂäõ
3. **ËµÑÊ∫êÁÆ°ÁêÜ**: ÂØπÂ∫îOpenManusÁöÑËµÑÊ∫êÊéßÂà∂Êú∫Âà∂
4. **ÂÆâÂÖ®ÈöîÁ¶ª**: ÂØπÂ∫îOpenManusÁöÑÂÆâÂÖ®Ê≤ôÁÆ±ËÆæËÆ°

### üìö ËøõÈò∂Â≠¶‰π†ÊñπÂêë

1. **ÂÆπÂô®ÁºñÊéí**: Kubernetes„ÄÅDocker Swarm
2. **ÂæÆÊúçÂä°Êû∂ÊûÑ**: ÊúçÂä°ÂèëÁé∞„ÄÅË¥üËΩΩÂùáË°°
3. **ÂÆâÂÖ®Âä†Âõ∫**: SELinux„ÄÅAppArmor„ÄÅseccomp
4. **ÊÄßËÉΩ‰ºòÂåñ**: ÂÆπÂô®ÊÄßËÉΩË∞É‰ºò„ÄÅËµÑÊ∫êÊ±†ÁÆ°ÁêÜ
5. **ÁõëÊéßÂëäË≠¶**: Prometheus„ÄÅGrafanaÈõÜÊàê

## ÂÆûÊñΩÊó∂Èó¥Ë°®

| Èò∂ÊÆµ | Êó∂Èó¥ | ‰∏ªË¶Å‰ªªÂä° | ‰∫§‰ªòÁâ© |
|------|------|----------|--------|
| Èò∂ÊÆµ1 | Á¨¨1-2Â§© | Âü∫Á°ÄËÆæÊñΩÊê≠Âª∫ | È°πÁõÆÁªìÊûÑ„ÄÅÈÖçÁΩÆÁ≥ªÁªü |
| Èò∂ÊÆµ2 | Á¨¨3-5Â§© | Ê≤ôÁÆ±Ê†∏ÂøÉÂÆûÁé∞ | Âü∫Á±ª„ÄÅDockerÂÆûÁé∞ |
| Èò∂ÊÆµ3 | Á¨¨6-7Â§© | Â∑•ÂÖ∑Á≥ªÁªüÈõÜÊàê | ÊâßË°åÂ∑•ÂÖ∑„ÄÅ‰ºöËØùÁÆ°ÁêÜ |
| Èò∂ÊÆµ4 | Á¨¨8-9Â§© | ‰ª£ÁêÜÈõÜÊàê | Ê≤ôÁÆ±‰ª£ÁêÜ„ÄÅÈóÆÈ¢òËß£ÂÜ≥ |
| Èò∂ÊÆµ5 | Á¨¨10Â§© | ÊµãËØïÂíåÊñáÊ°£ | ÊµãËØïÁî®‰æã„ÄÅÊºîÁ§∫Á®ãÂ∫è |

## ÊÄªÁªì

È°πÁõÆ7ÈÄöËøáÂÆûÁé∞ÂÆâÂÖ®ÁöÑÊ≤ôÁÆ±ÊâßË°åÁéØÂ¢ÉÔºå‰∏∫AI‰ª£ÁêÜÊèê‰æõ‰∫ÜÂº∫Â§ßÁöÑ‰ª£Á†ÅÊâßË°åËÉΩÂäõ„ÄÇÈÄöËøáDockerÂÆπÂô®ÊäÄÊúØÔºåÊàë‰ª¨ÂÆûÁé∞‰∫ÜÔºö

1. **ÂÆâÂÖ®ÈöîÁ¶ª**: ‰ΩøÁî®DockerÂÆπÂô®Êèê‰æõÂÆåÂÖ®ÈöîÁ¶ªÁöÑÊâßË°åÁéØÂ¢É
2. **Â§öËØ≠Ë®ÄÊîØÊåÅ**: ÊîØÊåÅPython„ÄÅJavaScript„ÄÅJava„ÄÅGo„ÄÅBashÁ≠âÂ§öÁßçËØ≠Ë®Ä
3. **ËµÑÊ∫êÊéßÂà∂**: ÂÆûÁé∞CPU„ÄÅÂÜÖÂ≠ò„ÄÅÊó∂Èó¥Á≠âÂ§öÁª¥Â∫¶ËµÑÊ∫êÈôêÂà∂
4. **‰ª£ÁêÜÈõÜÊàê**: Êó†ÁºùÈõÜÊàêÂà∞ReAct‰ª£ÁêÜÊû∂ÊûÑ‰∏≠
5. **‰ºöËØùÁÆ°ÁêÜ**: ÊîØÊåÅÈïøÊúü‰ºöËØùÂíåÁä∂ÊÄÅ‰øùÊåÅ

### üöÄ Ê†∏ÂøÉ‰ª∑ÂÄº

- **ÂÆâÂÖ®ÊÄß**: ÈÄöËøáÂÆπÂô®ÈöîÁ¶ªÂíåÊùÉÈôêÊéßÂà∂ÔºåÁ°Æ‰øù‰ª£Á†ÅÊâßË°åÁöÑÂÆâÂÖ®ÊÄß
- **ÂèØÊâ©Â±ïÊÄß**: Ê®°ÂùóÂåñËÆæËÆ°ÔºåÊòì‰∫éÊ∑ªÂä†Êñ∞ÁöÑÁºñÁ®ãËØ≠Ë®ÄÊîØÊåÅ
- **ÊòìÁî®ÊÄß**: ÁÆÄÊ¥ÅÁöÑAPIËÆæËÆ°Ôºå‰æø‰∫éÈõÜÊàêÂíå‰ΩøÁî®
- **ÂèØÈù†ÊÄß**: ÂÆåÂñÑÁöÑÈîôËØØÂ§ÑÁêÜÂíåËµÑÊ∫êÊ∏ÖÁêÜÊú∫Âà∂

### üìà Â≠¶‰π†Êî∂Ëé∑

ÈÄöËøáÈ°πÁõÆ7ÁöÑÂÆûÊñΩÔºå‰Ω†Â∞ÜÊéåÊè°Ôºö

1. **DockerÊäÄÊúØÊ†à**: ÂÆπÂô®ÂåñÂ∫îÁî®ÂºÄÂèëÂíåÈÉ®ÁΩ≤
2. **ÂºÇÊ≠•ÁºñÁ®ã**: PythonÂºÇÊ≠•ÁºñÁ®ãÁöÑÊúÄ‰Ω≥ÂÆûË∑µ
3. **ÂÆâÂÖ®ÁºñÁ®ã**: ‰ª£Á†ÅÊâßË°åÂÆâÂÖ®ÂíåÊùÉÈôêÊéßÂà∂
4. **Êû∂ÊûÑËÆæËÆ°**: Â§ßÂûãÁ≥ªÁªüÁöÑÊ®°ÂùóÂåñËÆæËÆ°
5. **ÊµãËØïÈ©±Âä®**: ÂÆåÊï¥ÁöÑÊµãËØïÊ°ÜÊû∂ÂíåÊµãËØïÁ≠ñÁï•

### üîÑ ‰∏éOpenManusÁöÑËÅîÁ≥ª

È°πÁõÆ7ÊòØOpenManusÊû∂ÊûÑ‰∏≠ÁöÑÈáçË¶ÅÁªÑÊàêÈÉ®ÂàÜÔºåÂÆÉ‰∏∫AI‰ª£ÁêÜÊèê‰æõ‰∫ÜÔºö

- **‰ª£Á†ÅÊâßË°åËÉΩÂäõ**: ËÆ©‰ª£ÁêÜËÉΩÂ§üÊâßË°åÂíåÈ™åËØÅ‰ª£Á†Å
- **Â§öËØ≠Ë®ÄÊîØÊåÅ**: Êâ©Â±ï‰ª£ÁêÜÁöÑÁºñÁ®ãËØ≠Ë®ÄÂ§ÑÁêÜËÉΩÂäõ
- **ÂÆâÂÖ®‰øùÈöú**: Á°Æ‰øù‰ª£Á†ÅÊâßË°åÁöÑÂÆâÂÖ®ÊÄßÂíåÂèØÊéßÊÄß
- **Â∑•ÂÖ∑ÁîüÊÄÅ**: ‰∏∞ÂØå‰ª£ÁêÜÁöÑÂ∑•ÂÖ∑ÈõÜÂêà

### üéØ ‰∏ã‰∏ÄÊ≠•ËÆ°Âàí

ÂÆåÊàêÈ°πÁõÆ7ÂêéÔºåÂª∫ËÆÆÁªßÁª≠Â≠¶‰π†Ôºö

1. **È°πÁõÆ8**: ÂàÜÂ∏ÉÂºè‰ª£ÁêÜÁ≥ªÁªü
2. **È°πÁõÆ9**: ‰ª£ÁêÜÂçè‰ΩúÂíåÈÄö‰ø°
3. **È°πÁõÆ10**: Áîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤ÂíåÁõëÊéß

ÈÄöËøáÂæ™Â∫èÊ∏êËøõÁöÑÂ≠¶‰π†Ôºå‰Ω†Â∞ÜÈÄêÊ≠•ÊéåÊè°ÊûÑÂª∫‰ºÅ‰∏öÁ∫ßAI‰ª£ÁêÜÁ≥ªÁªüÁöÑÂÆåÊï¥ÊäÄËÉΩÊ†à„ÄÇ

---

**Ê≥®ÊÑè**: Êú¨ÊñáÊ°£Êèê‰æõ‰∫ÜËØ¶ÁªÜÁöÑÂÆûÊñΩËÆ°ÂàíÂíå‰ª£Á†ÅÁ§∫‰æãÔºåÂª∫ËÆÆÊåâÁÖßÈò∂ÊÆµÈÄêÊ≠•ÂÆûÊñΩÔºåÁ°Æ‰øùÊØè‰∏™Èò∂ÊÆµÁöÑÂäüËÉΩÈÉΩËÉΩÊ≠£Â∏∏Â∑•‰ΩúÂêéÂÜçËøõÂÖ•‰∏ã‰∏ÄÈò∂ÊÆµ„ÄÇÂú®ÂÆûÊñΩËøáÁ®ã‰∏≠ÔºåÂèØ‰ª•Ê†πÊçÆÂÆûÈôÖÊÉÖÂÜµË∞ÉÊï¥ÂÖ∑‰ΩìÁöÑÂÆûÁé∞ÁªÜËäÇÔºå‰ΩÜË¶Å‰øùÊåÅÊï¥‰ΩìÊû∂ÊûÑÁöÑ‰∏ÄËá¥ÊÄß„ÄÇ